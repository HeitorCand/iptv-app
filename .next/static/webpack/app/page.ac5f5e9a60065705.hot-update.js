"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/api-service.ts":
/*!****************************!*\
  !*** ./lib/api-service.ts ***!
  \****************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ApiError: () => (/* binding */ ApiError),\n/* harmony export */   AuthenticationError: () => (/* binding */ AuthenticationError),\n/* harmony export */   NetworkError: () => (/* binding */ NetworkError),\n/* harmony export */   NotFoundError: () => (/* binding */ NotFoundError),\n/* harmony export */   getAllLiveStreams: () => (/* binding */ getAllLiveStreams),\n/* harmony export */   getAllMovies: () => (/* binding */ getAllMovies),\n/* harmony export */   getAllSeries: () => (/* binding */ getAllSeries),\n/* harmony export */   getContentCurrentTime: () => (/* binding */ getContentCurrentTime),\n/* harmony export */   getCredentials: () => (/* binding */ getCredentials),\n/* harmony export */   getErrorMessage: () => (/* binding */ getErrorMessage),\n/* harmony export */   getMovieInfo: () => (/* binding */ getMovieInfo),\n/* harmony export */   getSeriesInfo: () => (/* binding */ getSeriesInfo),\n/* harmony export */   getStreamUrl: () => (/* binding */ getStreamUrl),\n/* harmony export */   mapChannelToContent: () => (/* binding */ mapChannelToContent),\n/* harmony export */   mapMovieToContent: () => (/* binding */ mapMovieToContent),\n/* harmony export */   mapSeriesDetailsToContent: () => (/* binding */ mapSeriesDetailsToContent),\n/* harmony export */   mapSeriesToContent: () => (/* binding */ mapSeriesToContent),\n/* harmony export */   saveContentProgress: () => (/* binding */ saveContentProgress),\n/* harmony export */   searchContent: () => (/* binding */ searchContent),\n/* harmony export */   testConnection: () => (/* binding */ testConnection)\n/* harmony export */ });\n// Update the ApiCredentials interface to include forceHttps\n// Custom error classes\nclass AuthenticationError extends Error {\n    constructor(message = \"Authentication failed\"){\n        super(message);\n        this.name = \"AuthenticationError\";\n    }\n}\nclass NotFoundError extends Error {\n    constructor(message = \"Resource not found\"){\n        super(message);\n        this.name = \"NotFoundError\";\n    }\n}\nclass ApiError extends Error {\n    constructor(message = \"API error\", statusCode){\n        super(message);\n        this.name = \"ApiError\";\n        this.statusCode = statusCode;\n    }\n}\nclass NetworkError extends Error {\n    constructor(message = \"Network error\"){\n        super(message);\n        this.name = \"NetworkError\";\n    }\n}\n// Update the getCredentials function to handle the forceHttps option\nconst getCredentials = ()=>{\n    if (false) {}\n    const storedConfig = localStorage.getItem(\"streamConfig\");\n    if (!storedConfig) return null;\n    try {\n        const credentials = JSON.parse(storedConfig);\n        // If forceHttps is enabled, ensure the URL uses HTTPS\n        if (credentials.forceHttps && credentials.apiUrl.toLowerCase().startsWith(\"http:\")) {\n            credentials.apiUrl = credentials.apiUrl.replace(/^http:/i, \"https:\");\n        }\n        return credentials;\n    } catch (error) {\n        console.error(\"Failed to parse stored credentials:\", error);\n        return null;\n    }\n};\n// Update the apiRequest function to better handle mixed content errors\nasync function apiRequest(endpoint) {\n    let params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, retries = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 2;\n    const credentials = getCredentials();\n    if (!credentials) {\n        throw new AuthenticationError(\"Credenciais não encontradas. Configure o aplicativo primeiro.\");\n    }\n    const { apiUrl, username, password } = credentials;\n    // Build URL with credentials and params\n    let url;\n    try {\n        url = new URL(apiUrl);\n    } catch (error) {\n        throw new Error(\"URL inv\\xe1lida: \".concat(apiUrl, \". Verifique a configura\\xe7\\xe3o.\"));\n    }\n    // Check for potential mixed content issues\n    if ( true && window.location.protocol === \"https:\" && url.protocol === \"http:\") {\n        console.warn(\"Potential mixed content issue: trying to load HTTP content in an HTTPS page\");\n    }\n    // Add authentication params and action\n    const queryParams = new URLSearchParams({\n        username,\n        password,\n        action: endpoint,\n        ...params\n    });\n    let fullUrl = \"\".concat(url.toString(), \"?\").concat(queryParams.toString());\n    try {\n        const response = await fetch(fullUrl, {\n            method: \"GET\",\n            mode: \"cors\",\n            credentials: \"omit\",\n            headers: {\n                \"accept\": \"application/json\",\n                \"accept-language\": \"pt-BR,pt;q=0.9,en-US;q=0.8,en;q=0.7\"\n            },\n            signal: AbortSignal.timeout(30000)\n        });\n        // Clone the response for debugging\n        const responseClone = response.clone();\n        const data = await responseClone.json();\n        console.log(\"API Response Data:\", data);\n        // Handle different HTTP status codes\n        if (!response.ok) {\n            if (response.status === 401 || response.status === 403) {\n                throw new AuthenticationError();\n            } else if (response.status === 404) {\n                throw new NotFoundError();\n            } else {\n                throw new ApiError(\"Erro na API: \".concat(response.statusText), response.status);\n            }\n        }\n        // Parse JSON response\n        try {\n            const data = await response.json() // O await agora deve funcionar corretamente\n            ;\n            // Some APIs return error information in the response body\n            if (data && data.error) {\n                throw new ApiError(\"Erro na API: \".concat(data.error));\n            }\n            return data;\n        } catch (error) {\n            throw new ApiError(\"Erro ao processar resposta da API. Formato inválido.\");\n        }\n    } catch (error) {\n        // Handle timeout errors\n        if (error.name === \"AbortError\") {\n            console.error(\"A requisição demorou muito e foi abortada.\");\n            throw new NetworkError(\"A requisição excedeu o tempo limite. Tente novamente.\");\n        }\n        // Check specifically for mixed content errors\n        if (error instanceof TypeError) {\n            const errorMessage = error.message.toLowerCase();\n            if (errorMessage.includes(\"mixed content\") || errorMessage.includes(\"blocked\") && errorMessage.includes(\"insecure\")) {\n                throw new NetworkError(\"Erro de conteúdo misto: seu navegador bloqueou a requisição HTTP em um site HTTPS. \" + \"Tente ativar 'Forçar HTTPS' nas configurações ou use um servidor com HTTPS.\");\n            }\n            // Handle network errors and implement retry logic\n            if (errorMessage.includes(\"fetch\")) {\n                // Network error\n                if (retries > 0) {\n                    console.log(\"Retry attempt (\".concat(retries, \" remaining) for \").concat(fullUrl));\n                    // Exponential backoff: wait longer between retries\n                    await new Promise((resolve)=>setTimeout(resolve, (3 - retries) * 1000));\n                    return apiRequest(endpoint, params, retries - 1);\n                }\n                throw new NetworkError();\n            }\n        }\n        // Re-throw other errors\n        throw error;\n    }\n}\n// Update the getStreamUrl function to handle HTTPS\nconst getStreamUrl = (streamId, streamType, episodeId)=>{\n    const credentials = getCredentials();\n    if (!credentials) {\n        throw new AuthenticationError(\"Credenciais não encontradas. Configure o aplicativo primeiro.\");\n    }\n    const { apiUrl, username, password, forceHttps } = credentials;\n    let baseUrl = apiUrl.replace(\"player_api.php\", \"\");\n    // If forceHttps is enabled, ensure the URL uses HTTPS\n    if (forceHttps && baseUrl.toLowerCase().startsWith(\"http:\")) {\n        baseUrl = baseUrl.replace(/^http:/i, \"https:\");\n    }\n    if (streamType === \"live\") {\n        return \"\".concat(baseUrl, \"live/\").concat(username, \"/\").concat(password, \"/\").concat(streamId, \".ts\");\n    } else if (streamType === \"movie\") {\n        return \"\".concat(baseUrl, \"movie/\").concat(username, \"/\").concat(password, \"/\").concat(streamId, \".mp4\");\n    } else if (streamType === \"series\" && episodeId) {\n        return \"\".concat(baseUrl, \"series/\").concat(username, \"/\").concat(password, \"/\").concat(streamId, \"/\").concat(episodeId, \".mp4\");\n    }\n    throw new Error(\"Tipo de stream inválido ou ID de episódio ausente para séries\");\n};\n// API Endpoints and Data Mapping\nconst API_ENDPOINTS = {\n    GET_ALL_SERIES: \"get_series\",\n    GET_ALL_MOVIES: \"get_vod\",\n    GET_ALL_LIVE_STREAMS: \"get_live_streams\",\n    GET_SERIES_INFO: \"get_series_info\",\n    GET_MOVIE_INFO: \"get_vod_info\",\n    SEARCH: \"search\"\n};\n// API Calls\nconst getAllSeries = async function() {\n    let page = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1, pageSize = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 30;\n    const response = await apiRequest(\"get_series\");\n    let items = [];\n    if (Array.isArray(response)) {\n        items = response;\n    } else if (response && typeof response === \"object\") {\n        items = Object.values(response);\n    }\n    const start = (page - 1) * pageSize;\n    const end = start + pageSize;\n    return items.slice(start, end).map(mapSeriesToContent);\n};\nconst getAllMovies = async ()=>{\n    const response = await apiRequest(\"get_vod\");\n    return Object.entries(response.vod || {}).map((param)=>{\n        let [id, movie] = param;\n        return {\n            id,\n            ...movie\n        };\n    });\n};\nconst getAllLiveStreams = async ()=>{\n    const response = await apiRequest(\"get_live_streams\");\n    return Object.entries(response.live || {}).map((param)=>{\n        let [id, channel] = param;\n        return {\n            id,\n            ...channel\n        };\n    });\n};\nconst getSeriesInfo = async (seriesId)=>{\n    const response = await apiRequest(API_ENDPOINTS.GET_SERIES_INFO, {\n        series_id: seriesId\n    });\n    return response;\n};\nconst getMovieInfo = async (vodId)=>{\n    const response = await apiRequest(API_ENDPOINTS.GET_MOVIE_INFO, {\n        vod_id: vodId\n    });\n    return response;\n};\nconst searchContent = async (query)=>{\n    try {\n        const response = await apiRequest(API_ENDPOINTS.SEARCH, {\n            query: query\n        });\n        if (!response || !response.data) {\n            return [];\n        }\n        const seriesResults = Object.entries(response.data.series || {}).map((param)=>{\n            let [id, series] = param;\n            return mapSeriesToContent({\n                id,\n                ...series\n            });\n        });\n        const movieResults = Object.entries(response.data.vod || {}).map((param)=>{\n            let [id, movie] = param;\n            return mapMovieToContent({\n                id,\n                ...movie\n            });\n        });\n        const channelResults = Object.entries(response.data.live || {}).map((param)=>{\n            let [id, channel] = param;\n            return mapChannelToContent({\n                id,\n                ...channel\n            });\n        });\n        return [\n            ...seriesResults,\n            ...movieResults,\n            ...channelResults\n        ];\n    } catch (error) {\n        console.error(\"Search failed:\", error);\n        return [];\n    }\n};\n// Data Mapping Functions\nconst mapSeriesToContent = (series)=>{\n    var _series_cover;\n    let thumbnail = (_series_cover = series.cover) !== null && _series_cover !== void 0 ? _series_cover : \"\";\n    // Corrige domínio errado\n    if (thumbnail.startsWith(\"http://file.gstaticontent.com\")) {\n        thumbnail = thumbnail.replace(\"file.gstaticontent.com\", \"file.gstaticcontent.com\");\n    }\n    // Usa proxy para evitar CORS\n    if (thumbnail.startsWith(\"http://\") || thumbnail.startsWith(\"https://\")) {\n        thumbnail = \"https://images.weserv.nl/?url=\".concat(encodeURIComponent(thumbnail.replace(/^https?:\\/\\//, \"\")));\n    }\n    var _series_series_id, _series_name, _series_plot, _series_genre, _series_year;\n    return {\n        id: String((_series_series_id = series.series_id) !== null && _series_series_id !== void 0 ? _series_series_id : series.id),\n        title: (_series_name = series.name) !== null && _series_name !== void 0 ? _series_name : series.title,\n        description: (_series_plot = series.plot) !== null && _series_plot !== void 0 ? _series_plot : \"\",\n        thumbnail,\n        type: \"series\",\n        genre: (_series_genre = series.genre) !== null && _series_genre !== void 0 ? _series_genre : \"\",\n        year: (_series_year = series.year) !== null && _series_year !== void 0 ? _series_year : \"\",\n        backdrop: Array.isArray(series.backdrop_path) ? series.backdrop_path[0] : undefined,\n        info: series\n    };\n};\nconst mapMovieToContent = (movie)=>({\n        id: movie.id,\n        title: movie.name,\n        description: movie.plot,\n        thumbnail: movie.cover,\n        type: \"movie\",\n        genre: movie.genre,\n        year: movie.year,\n        duration: movie.duration\n    });\nconst mapChannelToContent = (channel)=>({\n        id: channel.id,\n        title: channel.name,\n        description: \"\",\n        thumbnail: channel.stream_icon,\n        type: \"channel\"\n    });\nconst mapSeriesDetailsToContent = (seriesDetails)=>{\n    const series = seriesDetails.info;\n    const episodes = Object.entries(seriesDetails.episodes || {}).map((param)=>{\n        let [episodeId, episode] = param;\n        return {\n            id: episodeId,\n            title: episode.title,\n            description: episode.plot,\n            duration: episode.duration\n        };\n    });\n    return {\n        id: series.id,\n        title: series.name,\n        description: series.plot,\n        thumbnail: series.cover,\n        type: \"series\",\n        genre: series.genre,\n        year: series.year,\n        episodes: episodes\n    };\n};\n// Local Storage Functions\nconst PROGRESS_KEY = \"contentProgress\";\nconst saveContentProgress = (contentId, currentTime, duration, episodeId)=>{\n    if (false) {}\n    try {\n        const progressData = JSON.parse(localStorage.getItem(PROGRESS_KEY) || \"{}\");\n        progressData[contentId + (episodeId ? \"_\".concat(episodeId) : \"\")] = {\n            currentTime,\n            duration\n        };\n        localStorage.setItem(PROGRESS_KEY, JSON.stringify(progressData));\n    } catch (error) {\n        console.error(\"Failed to save content progress:\", error);\n    }\n};\nconst getContentCurrentTime = (contentId, episodeId)=>{\n    if (false) {}\n    try {\n        const progressData = JSON.parse(localStorage.getItem(PROGRESS_KEY) || \"{}\");\n        const progress = progressData[contentId + (episodeId ? \"_\".concat(episodeId) : \"\")];\n        return progress ? progress.currentTime : null;\n    } catch (error) {\n        console.error(\"Failed to get content progress:\", error);\n        return null;\n    }\n};\n// Test Connection\nconst testConnection = async ()=>{\n    try {\n        // Attempt to fetch series (a basic API call)\n        await getAllSeries();\n        return true;\n    } catch (error) {\n        console.error(\"Connection test failed:\", error);\n        return false;\n    }\n};\n// Error Message Helper\nconst getErrorMessage = (error)=>{\n    if (error instanceof AuthenticationError) {\n        return \"Falha na autenticação. Verifique suas credenciais.\";\n    } else if (error instanceof NotFoundError) {\n        return \"Recurso não encontrado.\";\n    } else if (error instanceof ApiError) {\n        return \"Erro na API: \".concat(error.message);\n    } else if (error instanceof NetworkError) {\n        return \"Erro de rede. Verifique sua conexão com a internet.\";\n    } else if (error instanceof TypeError && error.message.includes(\"Failed to fetch\")) {\n        return \"Erro ao conectar ao servidor. Verifique a URL e sua conexão.\";\n    } else {\n        return \"Ocorreu um erro inesperado.\";\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LE9BQU8sSUFBSXFCLGlCQUFpQmhCLGVBQWU7UUFDekMsT0FBTztJQUNULE9BQU8sSUFBSWdCLGlCQUFpQmYsVUFBVTtRQUNwQyxPQUFPLGdCQUE4QixPQUFkZSxNQUFNbEIsT0FBTztJQUN0QyxPQUFPLElBQUlrQixpQkFBaUJiLGNBQWM7UUFDeEMsT0FBTztJQUNULE9BQU8sSUFBSWEsaUJBQWlCbUMsYUFBYW5DLE1BQU1sQixPQUFPLENBQUN1RCxRQUFRLENBQUMsb0JBQW9CO1FBQ2xGLE9BQU87SUFDVCxPQUFPO1FBQ0wsT0FBTztJQUNUO0FBQ0YsRUFBQyIsInNvdXJjZXMiOlsiL1VzZXJzL2hlaXRvci5jYW5kaWRvL0RvY3VtZW50cy9pcHR2L2lwdHYtYXBwL2xpYi9hcGktc2VydmljZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBVcGRhdGUgdGhlIEFwaUNyZWRlbnRpYWxzIGludGVyZmFjZSB0byBpbmNsdWRlIGZvcmNlSHR0cHNcbmV4cG9ydCBpbnRlcmZhY2UgQXBpQ3JlZGVudGlhbHMge1xuICBhcGlVcmw6IHN0cmluZ1xuICB1c2VybmFtZTogc3RyaW5nXG4gIHBhc3N3b3JkOiBzdHJpbmdcbiAgZm9yY2VIdHRwcz86IGJvb2xlYW5cbn1cblxuLy8gQ3VzdG9tIGVycm9yIGNsYXNzZXNcbmV4cG9ydCBjbGFzcyBBdXRoZW50aWNhdGlvbkVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlID0gXCJBdXRoZW50aWNhdGlvbiBmYWlsZWRcIikge1xuICAgIHN1cGVyKG1lc3NhZ2UpXG4gICAgdGhpcy5uYW1lID0gXCJBdXRoZW50aWNhdGlvbkVycm9yXCJcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgTm90Rm91bmRFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSA9IFwiUmVzb3VyY2Ugbm90IGZvdW5kXCIpIHtcbiAgICBzdXBlcihtZXNzYWdlKVxuICAgIHRoaXMubmFtZSA9IFwiTm90Rm91bmRFcnJvclwiXG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIEFwaUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBwdWJsaWMgc3RhdHVzQ29kZTogbnVtYmVyIHwgdW5kZWZpbmVkXG5cbiAgY29uc3RydWN0b3IobWVzc2FnZSA9IFwiQVBJIGVycm9yXCIsIHN0YXR1c0NvZGU/OiBudW1iZXIpIHtcbiAgICBzdXBlcihtZXNzYWdlKVxuICAgIHRoaXMubmFtZSA9IFwiQXBpRXJyb3JcIlxuICAgIHRoaXMuc3RhdHVzQ29kZSA9IHN0YXR1c0NvZGVcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgTmV0d29ya0Vycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlID0gXCJOZXR3b3JrIGVycm9yXCIpIHtcbiAgICBzdXBlcihtZXNzYWdlKVxuICAgIHRoaXMubmFtZSA9IFwiTmV0d29ya0Vycm9yXCJcbiAgfVxufVxuXG4vLyBVcGRhdGUgdGhlIGdldENyZWRlbnRpYWxzIGZ1bmN0aW9uIHRvIGhhbmRsZSB0aGUgZm9yY2VIdHRwcyBvcHRpb25cbmV4cG9ydCBjb25zdCBnZXRDcmVkZW50aWFscyA9ICgpOiBBcGlDcmVkZW50aWFscyB8IG51bGwgPT4ge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuIG51bGxcblxuICBjb25zdCBzdG9yZWRDb25maWcgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShcInN0cmVhbUNvbmZpZ1wiKVxuICBpZiAoIXN0b3JlZENvbmZpZykgcmV0dXJuIG51bGxcblxuICB0cnkge1xuICAgIGNvbnN0IGNyZWRlbnRpYWxzID0gSlNPTi5wYXJzZShzdG9yZWRDb25maWcpIGFzIEFwaUNyZWRlbnRpYWxzXG5cbiAgICAvLyBJZiBmb3JjZUh0dHBzIGlzIGVuYWJsZWQsIGVuc3VyZSB0aGUgVVJMIHVzZXMgSFRUUFNcbiAgICBpZiAoY3JlZGVudGlhbHMuZm9yY2VIdHRwcyAmJiBjcmVkZW50aWFscy5hcGlVcmwudG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKFwiaHR0cDpcIikpIHtcbiAgICAgIGNyZWRlbnRpYWxzLmFwaVVybCA9IGNyZWRlbnRpYWxzLmFwaVVybC5yZXBsYWNlKC9eaHR0cDovaSwgXCJodHRwczpcIilcbiAgICB9XG5cbiAgICByZXR1cm4gY3JlZGVudGlhbHNcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIHBhcnNlIHN0b3JlZCBjcmVkZW50aWFsczpcIiwgZXJyb3IpXG4gICAgcmV0dXJuIG51bGxcbiAgfVxufVxuXG4vLyBVcGRhdGUgdGhlIGFwaVJlcXVlc3QgZnVuY3Rpb24gdG8gYmV0dGVyIGhhbmRsZSBtaXhlZCBjb250ZW50IGVycm9yc1xuYXN5bmMgZnVuY3Rpb24gYXBpUmVxdWVzdDxUPihlbmRwb2ludDogc3RyaW5nLCBwYXJhbXM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7fSwgcmV0cmllcyA9IDIpOiBQcm9taXNlPFQ+IHtcbiAgY29uc3QgY3JlZGVudGlhbHMgPSBnZXRDcmVkZW50aWFscygpXG4gIGlmICghY3JlZGVudGlhbHMpIHtcbiAgICB0aHJvdyBuZXcgQXV0aGVudGljYXRpb25FcnJvcihcIkNyZWRlbmNpYWlzIG7Do28gZW5jb250cmFkYXMuIENvbmZpZ3VyZSBvIGFwbGljYXRpdm8gcHJpbWVpcm8uXCIpXG4gIH1cblxuICBjb25zdCB7IGFwaVVybCwgdXNlcm5hbWUsIHBhc3N3b3JkIH0gPSBjcmVkZW50aWFsc1xuXG4gIC8vIEJ1aWxkIFVSTCB3aXRoIGNyZWRlbnRpYWxzIGFuZCBwYXJhbXNcbiAgbGV0IHVybDogVVJMXG4gIHRyeSB7XG4gICAgdXJsID0gbmV3IFVSTChhcGlVcmwpXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVUkwgaW52w6FsaWRhOiAke2FwaVVybH0uIFZlcmlmaXF1ZSBhIGNvbmZpZ3VyYcOnw6NvLmApXG4gIH1cblxuICAvLyBDaGVjayBmb3IgcG90ZW50aWFsIG1peGVkIGNvbnRlbnQgaXNzdWVzXG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbCA9PT0gXCJodHRwczpcIiAmJiB1cmwucHJvdG9jb2wgPT09IFwiaHR0cDpcIikge1xuICAgIGNvbnNvbGUud2FybihcIlBvdGVudGlhbCBtaXhlZCBjb250ZW50IGlzc3VlOiB0cnlpbmcgdG8gbG9hZCBIVFRQIGNvbnRlbnQgaW4gYW4gSFRUUFMgcGFnZVwiKVxuICB9XG5cbiAgLy8gQWRkIGF1dGhlbnRpY2F0aW9uIHBhcmFtcyBhbmQgYWN0aW9uXG4gIGNvbnN0IHF1ZXJ5UGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh7XG4gICAgdXNlcm5hbWUsXG4gICAgcGFzc3dvcmQsXG4gICAgYWN0aW9uOiBlbmRwb2ludCwgLy8gQWRkIHRoZSBhY3Rpb24gcGFyYW1ldGVyIGhlcmVcbiAgICAuLi5wYXJhbXMsXG4gIH0pXG5cbiAgbGV0IGZ1bGxVcmwgPSBgJHt1cmwudG9TdHJpbmcoKX0/JHtxdWVyeVBhcmFtcy50b1N0cmluZygpfWBcblxuICB0cnkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goZnVsbFVybCwge1xuICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgbW9kZTogXCJjb3JzXCIsIC8vIEFsdGVyYWRvIGRlIFwibm8tY29yc1wiIHBhcmEgXCJjb3JzXCJcbiAgICAgIGNyZWRlbnRpYWxzOiBcIm9taXRcIixcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgXCJhY2NlcHRcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgIFwiYWNjZXB0LWxhbmd1YWdlXCI6IFwicHQtQlIscHQ7cT0wLjksZW4tVVM7cT0wLjgsZW47cT0wLjdcIixcbiAgICAgIH0sXG4gICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQoMzAwMDApLCAvLyBUaW1lb3V0IGRlIDMwIHNlZ3VuZG9zXG4gICAgfSlcblxuICAgIC8vIENsb25lIHRoZSByZXNwb25zZSBmb3IgZGVidWdnaW5nXG4gICAgY29uc3QgcmVzcG9uc2VDbG9uZSA9IHJlc3BvbnNlLmNsb25lKClcbiAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2VDbG9uZS5qc29uKClcbiAgICBjb25zb2xlLmxvZyhcIkFQSSBSZXNwb25zZSBEYXRhOlwiLCBkYXRhKVxuXG4gICAgLy8gSGFuZGxlIGRpZmZlcmVudCBIVFRQIHN0YXR1cyBjb2Rlc1xuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQwMSB8fCByZXNwb25zZS5zdGF0dXMgPT09IDQwMykge1xuICAgICAgICB0aHJvdyBuZXcgQXV0aGVudGljYXRpb25FcnJvcigpXG4gICAgICB9IGVsc2UgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDA0KSB7XG4gICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEVycm9yKClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBBcGlFcnJvcihgRXJybyBuYSBBUEk6ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gLCByZXNwb25zZS5zdGF0dXMpXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUGFyc2UgSlNPTiByZXNwb25zZVxuICAgIHRyeSB7XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpIC8vIE8gYXdhaXQgYWdvcmEgZGV2ZSBmdW5jaW9uYXIgY29ycmV0YW1lbnRlXG5cbiAgICAgIC8vIFNvbWUgQVBJcyByZXR1cm4gZXJyb3IgaW5mb3JtYXRpb24gaW4gdGhlIHJlc3BvbnNlIGJvZHlcbiAgICAgIGlmIChkYXRhICYmIGRhdGEuZXJyb3IpIHtcbiAgICAgICAgdGhyb3cgbmV3IEFwaUVycm9yKGBFcnJvIG5hIEFQSTogJHtkYXRhLmVycm9yfWApXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkYXRhIGFzIFRcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEFwaUVycm9yKFwiRXJybyBhbyBwcm9jZXNzYXIgcmVzcG9zdGEgZGEgQVBJLiBGb3JtYXRvIGludsOhbGlkby5cIilcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgLy8gSGFuZGxlIHRpbWVvdXQgZXJyb3JzXG4gICAgaWYgKGVycm9yLm5hbWUgPT09IFwiQWJvcnRFcnJvclwiKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiQSByZXF1aXNpw6fDo28gZGVtb3JvdSBtdWl0byBlIGZvaSBhYm9ydGFkYS5cIilcbiAgICAgIHRocm93IG5ldyBOZXR3b3JrRXJyb3IoXCJBIHJlcXVpc2nDp8OjbyBleGNlZGV1IG8gdGVtcG8gbGltaXRlLiBUZW50ZSBub3ZhbWVudGUuXCIpXG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgc3BlY2lmaWNhbGx5IGZvciBtaXhlZCBjb250ZW50IGVycm9yc1xuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIFR5cGVFcnJvcikge1xuICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gZXJyb3IubWVzc2FnZS50b0xvd2VyQ2FzZSgpXG5cbiAgICAgIGlmIChcbiAgICAgICAgZXJyb3JNZXNzYWdlLmluY2x1ZGVzKFwibWl4ZWQgY29udGVudFwiKSB8fFxuICAgICAgICAoZXJyb3JNZXNzYWdlLmluY2x1ZGVzKFwiYmxvY2tlZFwiKSAmJiBlcnJvck1lc3NhZ2UuaW5jbHVkZXMoXCJpbnNlY3VyZVwiKSlcbiAgICAgICkge1xuICAgICAgICB0aHJvdyBuZXcgTmV0d29ya0Vycm9yKFxuICAgICAgICAgIFwiRXJybyBkZSBjb250ZcO6ZG8gbWlzdG86IHNldSBuYXZlZ2Fkb3IgYmxvcXVlb3UgYSByZXF1aXNpw6fDo28gSFRUUCBlbSB1bSBzaXRlIEhUVFBTLiBcIiArXG4gICAgICAgICAgICBcIlRlbnRlIGF0aXZhciAnRm9yw6dhciBIVFRQUycgbmFzIGNvbmZpZ3VyYcOnw7VlcyBvdSB1c2UgdW0gc2Vydmlkb3IgY29tIEhUVFBTLlwiLFxuICAgICAgICApXG4gICAgICB9XG5cbiAgICAgIC8vIEhhbmRsZSBuZXR3b3JrIGVycm9ycyBhbmQgaW1wbGVtZW50IHJldHJ5IGxvZ2ljXG4gICAgICBpZiAoZXJyb3JNZXNzYWdlLmluY2x1ZGVzKFwiZmV0Y2hcIikpIHtcbiAgICAgICAgLy8gTmV0d29yayBlcnJvclxuICAgICAgICBpZiAocmV0cmllcyA+IDApIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhgUmV0cnkgYXR0ZW1wdCAoJHtyZXRyaWVzfSByZW1haW5pbmcpIGZvciAke2Z1bGxVcmx9YClcbiAgICAgICAgICAvLyBFeHBvbmVudGlhbCBiYWNrb2ZmOiB3YWl0IGxvbmdlciBiZXR3ZWVuIHJldHJpZXNcbiAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCAoMyAtIHJldHJpZXMpICogMTAwMCkpXG4gICAgICAgICAgcmV0dXJuIGFwaVJlcXVlc3Q8VD4oZW5kcG9pbnQsIHBhcmFtcywgcmV0cmllcyAtIDEpXG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IE5ldHdvcmtFcnJvcigpXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmUtdGhyb3cgb3RoZXIgZXJyb3JzXG4gICAgdGhyb3cgZXJyb3JcbiAgfVxufVxuXG4vLyBVcGRhdGUgdGhlIGdldFN0cmVhbVVybCBmdW5jdGlvbiB0byBoYW5kbGUgSFRUUFNcbmV4cG9ydCBjb25zdCBnZXRTdHJlYW1VcmwgPSAoc3RyZWFtSWQ6IHN0cmluZywgc3RyZWFtVHlwZTogXCJsaXZlXCIgfCBcIm1vdmllXCIgfCBcInNlcmllc1wiLCBlcGlzb2RlSWQ/OiBzdHJpbmcpOiBzdHJpbmcgPT4ge1xuICBjb25zdCBjcmVkZW50aWFscyA9IGdldENyZWRlbnRpYWxzKClcbiAgaWYgKCFjcmVkZW50aWFscykge1xuICAgIHRocm93IG5ldyBBdXRoZW50aWNhdGlvbkVycm9yKFwiQ3JlZGVuY2lhaXMgbsOjbyBlbmNvbnRyYWRhcy4gQ29uZmlndXJlIG8gYXBsaWNhdGl2byBwcmltZWlyby5cIilcbiAgfVxuXG4gIGNvbnN0IHsgYXBpVXJsLCB1c2VybmFtZSwgcGFzc3dvcmQsIGZvcmNlSHR0cHMgfSA9IGNyZWRlbnRpYWxzXG4gIGxldCBiYXNlVXJsID0gYXBpVXJsLnJlcGxhY2UoXCJwbGF5ZXJfYXBpLnBocFwiLCBcIlwiKVxuXG4gIC8vIElmIGZvcmNlSHR0cHMgaXMgZW5hYmxlZCwgZW5zdXJlIHRoZSBVUkwgdXNlcyBIVFRQU1xuICBpZiAoZm9yY2VIdHRwcyAmJiBiYXNlVXJsLnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aChcImh0dHA6XCIpKSB7XG4gICAgYmFzZVVybCA9IGJhc2VVcmwucmVwbGFjZSgvXmh0dHA6L2ksIFwiaHR0cHM6XCIpXG4gIH1cblxuICBpZiAoc3RyZWFtVHlwZSA9PT0gXCJsaXZlXCIpIHtcbiAgICByZXR1cm4gYCR7YmFzZVVybH1saXZlLyR7dXNlcm5hbWV9LyR7cGFzc3dvcmR9LyR7c3RyZWFtSWR9LnRzYFxuICB9IGVsc2UgaWYgKHN0cmVhbVR5cGUgPT09IFwibW92aWVcIikge1xuICAgIHJldHVybiBgJHtiYXNlVXJsfW1vdmllLyR7dXNlcm5hbWV9LyR7cGFzc3dvcmR9LyR7c3RyZWFtSWR9Lm1wNGBcbiAgfSBlbHNlIGlmIChzdHJlYW1UeXBlID09PSBcInNlcmllc1wiICYmIGVwaXNvZGVJZCkge1xuICAgIHJldHVybiBgJHtiYXNlVXJsfXNlcmllcy8ke3VzZXJuYW1lfS8ke3Bhc3N3b3JkfS8ke3N0cmVhbUlkfS8ke2VwaXNvZGVJZH0ubXA0YFxuICB9XG5cbiAgdGhyb3cgbmV3IEVycm9yKFwiVGlwbyBkZSBzdHJlYW0gaW52w6FsaWRvIG91IElEIGRlIGVwaXPDs2RpbyBhdXNlbnRlIHBhcmEgc8Opcmllc1wiKVxufVxuXG4vLyBBUEkgRW5kcG9pbnRzIGFuZCBEYXRhIE1hcHBpbmdcbmNvbnN0IEFQSV9FTkRQT0lOVFMgPSB7XG4gIEdFVF9BTExfU0VSSUVTOiBcImdldF9zZXJpZXNcIixcbiAgR0VUX0FMTF9NT1ZJRVM6IFwiZ2V0X3ZvZFwiLFxuICBHRVRfQUxMX0xJVkVfU1RSRUFNUzogXCJnZXRfbGl2ZV9zdHJlYW1zXCIsXG4gIEdFVF9TRVJJRVNfSU5GTzogXCJnZXRfc2VyaWVzX2luZm9cIixcbiAgR0VUX01PVklFX0lORk86IFwiZ2V0X3ZvZF9pbmZvXCIsXG4gIFNFQVJDSDogXCJzZWFyY2hcIixcbn1cblxuaW50ZXJmYWNlIEFwaVJlc3BvbnNlPFQ+IHtcbiAgc3RhdHVzOiBib29sZWFuXG4gIGRhdGE6IFRcbiAgZXJyb3I/OiBzdHJpbmdcbn1cblxuLy8gRGF0YSBUeXBlc1xuZXhwb3J0IGludGVyZmFjZSBDb250ZW50SXRlbSB7XG4gIGlkOiBzdHJpbmdcbiAgdGl0bGU6IHN0cmluZ1xuICBkZXNjcmlwdGlvbjogc3RyaW5nXG4gIHRodW1ibmFpbDogc3RyaW5nXG4gIGJhY2tkcm9wPzogc3RyaW5nXG4gIHR5cGU6IFwic2VyaWVzXCIgfCBcIm1vdmllXCIgfCBcImNoYW5uZWxcIlxuICBnZW5yZT86IHN0cmluZ1xuICB5ZWFyPzogc3RyaW5nXG4gIGR1cmF0aW9uPzogc3RyaW5nXG4gIHByb2dyZXNzPzogbnVtYmVyXG4gIGVwaXNvZGVzPzogRXBpc29kZVtdXG4gIGluZm8/OiBhbnlcbn1cblxuZXhwb3J0IGludGVyZmFjZSBFcGlzb2RlIHtcbiAgaWQ6IHN0cmluZ1xuICB0aXRsZTogc3RyaW5nXG4gIGRlc2NyaXB0aW9uOiBzdHJpbmdcbiAgdGh1bWJuYWlsPzogc3RyaW5nXG4gIGR1cmF0aW9uPzogc3RyaW5nXG4gIHByb2dyZXNzPzogbnVtYmVyXG59XG5cbmludGVyZmFjZSBTZXJpZXNSZXNwb25zZSB7XG4gIHNlcmllczoge1xuICAgIFtzZXJpZXNJZDogc3RyaW5nXToge1xuICAgICAgbmFtZTogc3RyaW5nXG4gICAgICBjb3Zlcjogc3RyaW5nXG4gICAgICBwbG90OiBzdHJpbmdcbiAgICAgIGdlbnJlOiBzdHJpbmdcbiAgICAgIHllYXI6IHN0cmluZ1xuICAgICAgZXBpc29kZV9kZXRhaWxzOiB7XG4gICAgICAgIFtlcGlzb2RlSWQ6IHN0cmluZ106IHtcbiAgICAgICAgICB0aXRsZTogc3RyaW5nXG4gICAgICAgICAgcGxvdDogc3RyaW5nXG4gICAgICAgICAgZXBpc29kZV9udW06IHN0cmluZ1xuICAgICAgICAgIHNlYXNvbl9udW06IHN0cmluZ1xuICAgICAgICAgIGR1cmF0aW9uOiBzdHJpbmdcbiAgICAgICAgICBjdXN0b21fc2lkOiBzdHJpbmdcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5pbnRlcmZhY2UgTW92aWVSZXNwb25zZSB7XG4gIHZvZDoge1xuICAgIFttb3ZpZUlkOiBzdHJpbmddOiB7XG4gICAgICBuYW1lOiBzdHJpbmdcbiAgICAgIGNvdmVyOiBzdHJpbmdcbiAgICAgIHBsb3Q6IHN0cmluZ1xuICAgICAgZ2VucmU6IHN0cmluZ1xuICAgICAgeWVhcjogc3RyaW5nXG4gICAgICBkdXJhdGlvbjogc3RyaW5nXG4gICAgfVxuICB9XG59XG5cbmludGVyZmFjZSBMaXZlU3RyZWFtUmVzcG9uc2Uge1xuICBsaXZlOiB7XG4gICAgW2NoYW5uZWxJZDogc3RyaW5nXToge1xuICAgICAgbmFtZTogc3RyaW5nXG4gICAgICBzdHJlYW1faWNvbjogc3RyaW5nXG4gICAgICBlcGdfY2hhbm5lbF9pZDogc3RyaW5nXG4gICAgfVxuICB9XG59XG5cbi8vIEFQSSBDYWxsc1xuZXhwb3J0IGNvbnN0IGdldEFsbFNlcmllcyA9IGFzeW5jIChwYWdlID0gMSwgcGFnZVNpemUgPSAzMCk6IFByb21pc2U8Q29udGVudEl0ZW1bXT4gPT4ge1xuICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaVJlcXVlc3Q8YW55PihcImdldF9zZXJpZXNcIilcbiAgbGV0IGl0ZW1zOiBhbnlbXSA9IFtdXG4gIGlmIChBcnJheS5pc0FycmF5KHJlc3BvbnNlKSkge1xuICAgIGl0ZW1zID0gcmVzcG9uc2VcbiAgfSBlbHNlIGlmIChyZXNwb25zZSAmJiB0eXBlb2YgcmVzcG9uc2UgPT09IFwib2JqZWN0XCIpIHtcbiAgICBpdGVtcyA9IE9iamVjdC52YWx1ZXMocmVzcG9uc2UpXG4gIH1cbiAgY29uc3Qgc3RhcnQgPSAocGFnZSAtIDEpICogcGFnZVNpemVcbiAgY29uc3QgZW5kID0gc3RhcnQgKyBwYWdlU2l6ZVxuICByZXR1cm4gaXRlbXMuc2xpY2Uoc3RhcnQsIGVuZCkubWFwKG1hcFNlcmllc1RvQ29udGVudClcbn1cblxuZXhwb3J0IGNvbnN0IGdldEFsbE1vdmllcyA9IGFzeW5jICgpOiBQcm9taXNlPGFueVtdPiA9PiB7XG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpUmVxdWVzdDxhbnk+KFwiZ2V0X3ZvZFwiKVxuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzcG9uc2Uudm9kIHx8IHt9KS5tYXAoKFtpZCwgbW92aWVdKSA9PiAoeyBpZCwgLi4ubW92aWUgfSkpXG59XG5cbmV4cG9ydCBjb25zdCBnZXRBbGxMaXZlU3RyZWFtcyA9IGFzeW5jICgpOiBQcm9taXNlPGFueVtdPiA9PiB7XG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpUmVxdWVzdDxhbnk+KFwiZ2V0X2xpdmVfc3RyZWFtc1wiKVxuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzcG9uc2UubGl2ZSB8fCB7fSkubWFwKChbaWQsIGNoYW5uZWxdKSA9PiAoeyBpZCwgLi4uY2hhbm5lbCB9KSlcbn1cblxuZXhwb3J0IGNvbnN0IGdldFNlcmllc0luZm8gPSBhc3luYyAoc2VyaWVzSWQ6IHN0cmluZyk6IFByb21pc2U8YW55PiA9PiB7XG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpUmVxdWVzdDxhbnk+KEFQSV9FTkRQT0lOVFMuR0VUX1NFUklFU19JTkZPLCB7IHNlcmllc19pZDogc2VyaWVzSWQgfSlcbiAgcmV0dXJuIHJlc3BvbnNlXG59XG5cbmV4cG9ydCBjb25zdCBnZXRNb3ZpZUluZm8gPSBhc3luYyAodm9kSWQ6IHN0cmluZyk6IFByb21pc2U8YW55PiA9PiB7XG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpUmVxdWVzdDxhbnk+KEFQSV9FTkRQT0lOVFMuR0VUX01PVklFX0lORk8sIHsgdm9kX2lkOiB2b2RJZCB9KVxuICByZXR1cm4gcmVzcG9uc2Vcbn1cblxuZXhwb3J0IGNvbnN0IHNlYXJjaENvbnRlbnQgPSBhc3luYyAocXVlcnk6IHN0cmluZyk6IFByb21pc2U8Q29udGVudEl0ZW1bXT4gPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpUmVxdWVzdDxhbnk+KEFQSV9FTkRQT0lOVFMuU0VBUkNILCB7IHF1ZXJ5OiBxdWVyeSB9KVxuXG4gICAgaWYgKCFyZXNwb25zZSB8fCAhcmVzcG9uc2UuZGF0YSkge1xuICAgICAgcmV0dXJuIFtdXG4gICAgfVxuXG4gICAgY29uc3Qgc2VyaWVzUmVzdWx0cyA9IE9iamVjdC5lbnRyaWVzKHJlc3BvbnNlLmRhdGEuc2VyaWVzIHx8IHt9KS5tYXAoKFtpZCwgc2VyaWVzXSkgPT5cbiAgICAgIG1hcFNlcmllc1RvQ29udGVudCh7IGlkLCAuLi5zZXJpZXMgfSksXG4gICAgKVxuICAgIGNvbnN0IG1vdmllUmVzdWx0cyA9IE9iamVjdC5lbnRyaWVzKHJlc3BvbnNlLmRhdGEudm9kIHx8IHt9KS5tYXAoKFtpZCwgbW92aWVdKSA9PlxuICAgICAgbWFwTW92aWVUb0NvbnRlbnQoeyBpZCwgLi4ubW92aWUgfSksXG4gICAgKVxuICAgIGNvbnN0IGNoYW5uZWxSZXN1bHRzID0gT2JqZWN0LmVudHJpZXMocmVzcG9uc2UuZGF0YS5saXZlIHx8IHt9KS5tYXAoKFtpZCwgY2hhbm5lbF0pID0+XG4gICAgICBtYXBDaGFubmVsVG9Db250ZW50KHsgaWQsIC4uLmNoYW5uZWwgfSksXG4gICAgKVxuXG4gICAgcmV0dXJuIFsuLi5zZXJpZXNSZXN1bHRzLCAuLi5tb3ZpZVJlc3VsdHMsIC4uLmNoYW5uZWxSZXN1bHRzXVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJTZWFyY2ggZmFpbGVkOlwiLCBlcnJvcilcbiAgICByZXR1cm4gW11cbiAgfVxufVxuXG4vLyBEYXRhIE1hcHBpbmcgRnVuY3Rpb25zXG5leHBvcnQgY29uc3QgbWFwU2VyaWVzVG9Db250ZW50ID0gKHNlcmllczogYW55KTogQ29udGVudEl0ZW0gPT4ge1xuICBsZXQgdGh1bWJuYWlsID0gc2VyaWVzLmNvdmVyID8/IFwiXCJcbiAgLy8gQ29ycmlnZSBkb23DrW5pbyBlcnJhZG9cbiAgaWYgKHRodW1ibmFpbC5zdGFydHNXaXRoKFwiaHR0cDovL2ZpbGUuZ3N0YXRpY29udGVudC5jb21cIikpIHtcbiAgICB0aHVtYm5haWwgPSB0aHVtYm5haWwucmVwbGFjZShcImZpbGUuZ3N0YXRpY29udGVudC5jb21cIiwgXCJmaWxlLmdzdGF0aWNjb250ZW50LmNvbVwiKVxuICB9XG4gIC8vIFVzYSBwcm94eSBwYXJhIGV2aXRhciBDT1JTXG4gIGlmICh0aHVtYm5haWwuc3RhcnRzV2l0aChcImh0dHA6Ly9cIikgfHwgdGh1bWJuYWlsLnN0YXJ0c1dpdGgoXCJodHRwczovL1wiKSkge1xuICAgIHRodW1ibmFpbCA9IGBodHRwczovL2ltYWdlcy53ZXNlcnYubmwvP3VybD0ke2VuY29kZVVSSUNvbXBvbmVudCh0aHVtYm5haWwucmVwbGFjZSgvXmh0dHBzPzpcXC9cXC8vLCBcIlwiKSl9YFxuICB9XG4gIHJldHVybiB7XG4gICAgaWQ6IFN0cmluZyhzZXJpZXMuc2VyaWVzX2lkID8/IHNlcmllcy5pZCksXG4gICAgdGl0bGU6IHNlcmllcy5uYW1lID8/IHNlcmllcy50aXRsZSxcbiAgICBkZXNjcmlwdGlvbjogc2VyaWVzLnBsb3QgPz8gXCJcIixcbiAgICB0aHVtYm5haWwsXG4gICAgdHlwZTogXCJzZXJpZXNcIixcbiAgICBnZW5yZTogc2VyaWVzLmdlbnJlID8/IFwiXCIsXG4gICAgeWVhcjogc2VyaWVzLnllYXIgPz8gXCJcIixcbiAgICBiYWNrZHJvcDogQXJyYXkuaXNBcnJheShzZXJpZXMuYmFja2Ryb3BfcGF0aCkgPyBzZXJpZXMuYmFja2Ryb3BfcGF0aFswXSA6IHVuZGVmaW5lZCxcbiAgICBpbmZvOiBzZXJpZXMsXG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IG1hcE1vdmllVG9Db250ZW50ID0gKG1vdmllOiBhbnkpOiBDb250ZW50SXRlbSA9PiAoe1xuICBpZDogbW92aWUuaWQsXG4gIHRpdGxlOiBtb3ZpZS5uYW1lLFxuICBkZXNjcmlwdGlvbjogbW92aWUucGxvdCxcbiAgdGh1bWJuYWlsOiBtb3ZpZS5jb3ZlcixcbiAgdHlwZTogXCJtb3ZpZVwiLFxuICBnZW5yZTogbW92aWUuZ2VucmUsXG4gIHllYXI6IG1vdmllLnllYXIsXG4gIGR1cmF0aW9uOiBtb3ZpZS5kdXJhdGlvbixcbn0pXG5cbmV4cG9ydCBjb25zdCBtYXBDaGFubmVsVG9Db250ZW50ID0gKGNoYW5uZWw6IGFueSk6IENvbnRlbnRJdGVtID0+ICh7XG4gIGlkOiBjaGFubmVsLmlkLFxuICB0aXRsZTogY2hhbm5lbC5uYW1lLFxuICBkZXNjcmlwdGlvbjogXCJcIixcbiAgdGh1bWJuYWlsOiBjaGFubmVsLnN0cmVhbV9pY29uLFxuICB0eXBlOiBcImNoYW5uZWxcIixcbn0pXG5cbmV4cG9ydCBjb25zdCBtYXBTZXJpZXNEZXRhaWxzVG9Db250ZW50ID0gKHNlcmllc0RldGFpbHM6IGFueSk6IENvbnRlbnRJdGVtID0+IHtcbiAgY29uc3Qgc2VyaWVzID0gc2VyaWVzRGV0YWlscy5pbmZvXG4gIGNvbnN0IGVwaXNvZGVzOiBFcGlzb2RlW10gPSBPYmplY3QuZW50cmllcyhzZXJpZXNEZXRhaWxzLmVwaXNvZGVzIHx8IHt9KS5tYXAoXG4gICAgKFtlcGlzb2RlSWQsIGVwaXNvZGVdOiBbc3RyaW5nLCBhbnldKSA9PiAoe1xuICAgICAgaWQ6IGVwaXNvZGVJZCxcbiAgICAgIHRpdGxlOiBlcGlzb2RlLnRpdGxlLFxuICAgICAgZGVzY3JpcHRpb246IGVwaXNvZGUucGxvdCxcbiAgICAgIGR1cmF0aW9uOiBlcGlzb2RlLmR1cmF0aW9uLFxuICAgIH0pLFxuICApXG5cbiAgcmV0dXJuIHtcbiAgICBpZDogc2VyaWVzLmlkLFxuICAgIHRpdGxlOiBzZXJpZXMubmFtZSxcbiAgICBkZXNjcmlwdGlvbjogc2VyaWVzLnBsb3QsXG4gICAgdGh1bWJuYWlsOiBzZXJpZXMuY292ZXIsXG4gICAgdHlwZTogXCJzZXJpZXNcIixcbiAgICBnZW5yZTogc2VyaWVzLmdlbnJlLFxuICAgIHllYXI6IHNlcmllcy55ZWFyLFxuICAgIGVwaXNvZGVzOiBlcGlzb2RlcyxcbiAgfVxufVxuXG4vLyBMb2NhbCBTdG9yYWdlIEZ1bmN0aW9uc1xuY29uc3QgUFJPR1JFU1NfS0VZID0gXCJjb250ZW50UHJvZ3Jlc3NcIlxuXG5leHBvcnQgY29uc3Qgc2F2ZUNvbnRlbnRQcm9ncmVzcyA9IChjb250ZW50SWQ6IHN0cmluZywgY3VycmVudFRpbWU6IG51bWJlciwgZHVyYXRpb246IG51bWJlciwgZXBpc29kZUlkPzogc3RyaW5nKSA9PiB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSByZXR1cm5cblxuICB0cnkge1xuICAgIGNvbnN0IHByb2dyZXNzRGF0YSA9IEpTT04ucGFyc2UobG9jYWxTdG9yYWdlLmdldEl0ZW0oUFJPR1JFU1NfS0VZKSB8fCBcInt9XCIpXG4gICAgcHJvZ3Jlc3NEYXRhW2NvbnRlbnRJZCArIChlcGlzb2RlSWQgPyBgXyR7ZXBpc29kZUlkfWAgOiBcIlwiKV0gPSB7IGN1cnJlbnRUaW1lLCBkdXJhdGlvbiB9XG4gICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oUFJPR1JFU1NfS0VZLCBKU09OLnN0cmluZ2lmeShwcm9ncmVzc0RhdGEpKVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gc2F2ZSBjb250ZW50IHByb2dyZXNzOlwiLCBlcnJvcilcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgZ2V0Q29udGVudEN1cnJlbnRUaW1lID0gKGNvbnRlbnRJZDogc3RyaW5nLCBlcGlzb2RlSWQ/OiBzdHJpbmcpOiBudW1iZXIgfCBudWxsID0+IHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHJldHVybiBudWxsXG5cbiAgdHJ5IHtcbiAgICBjb25zdCBwcm9ncmVzc0RhdGEgPSBKU09OLnBhcnNlKGxvY2FsU3RvcmFnZS5nZXRJdGVtKFBST0dSRVNTX0tFWSkgfHwgXCJ7fVwiKVxuICAgIGNvbnN0IHByb2dyZXNzID0gcHJvZ3Jlc3NEYXRhW2NvbnRlbnRJZCArIChlcGlzb2RlSWQgPyBgXyR7ZXBpc29kZUlkfWAgOiBcIlwiKV1cbiAgICByZXR1cm4gcHJvZ3Jlc3MgPyBwcm9ncmVzcy5jdXJyZW50VGltZSA6IG51bGxcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIGdldCBjb250ZW50IHByb2dyZXNzOlwiLCBlcnJvcilcbiAgICByZXR1cm4gbnVsbFxuICB9XG59XG5cbi8vIFRlc3QgQ29ubmVjdGlvblxuZXhwb3J0IGNvbnN0IHRlc3RDb25uZWN0aW9uID0gYXN5bmMgKCk6IFByb21pc2U8Ym9vbGVhbj4gPT4ge1xuICB0cnkge1xuICAgIC8vIEF0dGVtcHQgdG8gZmV0Y2ggc2VyaWVzIChhIGJhc2ljIEFQSSBjYWxsKVxuICAgIGF3YWl0IGdldEFsbFNlcmllcygpXG4gICAgcmV0dXJuIHRydWVcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiQ29ubmVjdGlvbiB0ZXN0IGZhaWxlZDpcIiwgZXJyb3IpXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuLy8gRXJyb3IgTWVzc2FnZSBIZWxwZXJcbmV4cG9ydCBjb25zdCBnZXRFcnJvck1lc3NhZ2UgPSAoZXJyb3I6IGFueSk6IHN0cmluZyA9PiB7XG4gIGlmIChlcnJvciBpbnN0YW5jZW9mIEF1dGhlbnRpY2F0aW9uRXJyb3IpIHtcbiAgICByZXR1cm4gXCJGYWxoYSBuYSBhdXRlbnRpY2HDp8Ojby4gVmVyaWZpcXVlIHN1YXMgY3JlZGVuY2lhaXMuXCJcbiAgfSBlbHNlIGlmIChlcnJvciBpbnN0YW5jZW9mIE5vdEZvdW5kRXJyb3IpIHtcbiAgICByZXR1cm4gXCJSZWN1cnNvIG7Do28gZW5jb250cmFkby5cIlxuICB9IGVsc2UgaWYgKGVycm9yIGluc3RhbmNlb2YgQXBpRXJyb3IpIHtcbiAgICByZXR1cm4gYEVycm8gbmEgQVBJOiAke2Vycm9yLm1lc3NhZ2V9YFxuICB9IGVsc2UgaWYgKGVycm9yIGluc3RhbmNlb2YgTmV0d29ya0Vycm9yKSB7XG4gICAgcmV0dXJuIFwiRXJybyBkZSByZWRlLiBWZXJpZmlxdWUgc3VhIGNvbmV4w6NvIGNvbSBhIGludGVybmV0LlwiXG4gIH0gZWxzZSBpZiAoZXJyb3IgaW5zdGFuY2VvZiBUeXBlRXJyb3IgJiYgZXJyb3IubWVzc2FnZS5pbmNsdWRlcyhcIkZhaWxlZCB0byBmZXRjaFwiKSkge1xuICAgIHJldHVybiBcIkVycm8gYW8gY29uZWN0YXIgYW8gc2Vydmlkb3IuIFZlcmlmaXF1ZSBhIFVSTCBlIHN1YSBjb25leMOjby5cIlxuICB9IGVsc2Uge1xuICAgIHJldHVybiBcIk9jb3JyZXUgdW0gZXJybyBpbmVzcGVyYWRvLlwiXG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJBdXRoZW50aWNhdGlvbkVycm9yIiwiRXJyb3IiLCJjb25zdHJ1Y3RvciIsIm1lc3NhZ2UiLCJuYW1lIiwiTm90Rm91bmRFcnJvciIsIkFwaUVycm9yIiwic3RhdHVzQ29kZSIsIk5ldHdvcmtFcnJvciIsImdldENyZWRlbnRpYWxzIiwic3RvcmVkQ29uZmlnIiwibG9jYWxTdG9yYWdlIiwiZ2V0SXRlbSIsImNyZWRlbnRpYWxzIiwiSlNPTiIsInBhcnNlIiwiZm9yY2VIdHRwcyIsImFwaVVybCIsInRvTG93ZXJDYXNlIiwic3RhcnRzV2l0aCIsInJlcGxhY2UiLCJlcnJvciIsImNvbnNvbGUiLCJhcGlSZXF1ZXN0IiwiZW5kcG9pbnQiLCJwYXJhbXMiLCJyZXRyaWVzIiwidXNlcm5hbWUiLCJwYXNzd29yZCIsInVybCIsIlVSTCIsIndpbmRvdyIsImxvY2F0aW9uIiwicHJvdG9jb2wiLCJ3YXJuIiwicXVlcnlQYXJhbXMiLCJVUkxTZWFyY2hQYXJhbXMiLCJhY3Rpb24iLCJmdWxsVXJsIiwidG9TdHJpbmciLCJyZXNwb25zZSIsImZldGNoIiwibWV0aG9kIiwibW9kZSIsImhlYWRlcnMiLCJzaWduYWwiLCJBYm9ydFNpZ25hbCIsInRpbWVvdXQiLCJyZXNwb25zZUNsb25lIiwiY2xvbmUiLCJkYXRhIiwianNvbiIsImxvZyIsIm9rIiwic3RhdHVzIiwic3RhdHVzVGV4dCIsIlR5cGVFcnJvciIsImVycm9yTWVzc2FnZSIsImluY2x1ZGVzIiwiUHJvbWlzZSIsInJlc29sdmUiLCJzZXRUaW1lb3V0IiwiZ2V0U3RyZWFtVXJsIiwic3RyZWFtSWQiLCJzdHJlYW1UeXBlIiwiZXBpc29kZUlkIiwiYmFzZVVybCIsIkFQSV9FTkRQT0lOVFMiLCJHRVRfQUxMX1NFUklFUyIsIkdFVF9BTExfTU9WSUVTIiwiR0VUX0FMTF9MSVZFX1NUUkVBTVMiLCJHRVRfU0VSSUVTX0lORk8iLCJHRVRfTU9WSUVfSU5GTyIsIlNFQVJDSCIsImdldEFsbFNlcmllcyIsInBhZ2UiLCJwYWdlU2l6ZSIsIml0ZW1zIiwiQXJyYXkiLCJpc0FycmF5IiwiT2JqZWN0IiwidmFsdWVzIiwic3RhcnQiLCJlbmQiLCJzbGljZSIsIm1hcCIsIm1hcFNlcmllc1RvQ29udGVudCIsImdldEFsbE1vdmllcyIsImVudHJpZXMiLCJ2b2QiLCJpZCIsIm1vdmllIiwiZ2V0QWxsTGl2ZVN0cmVhbXMiLCJsaXZlIiwiY2hhbm5lbCIsImdldFNlcmllc0luZm8iLCJzZXJpZXNJZCIsInNlcmllc19pZCIsImdldE1vdmllSW5mbyIsInZvZElkIiwidm9kX2lkIiwic2VhcmNoQ29udGVudCIsInF1ZXJ5Iiwic2VyaWVzUmVzdWx0cyIsInNlcmllcyIsIm1vdmllUmVzdWx0cyIsIm1hcE1vdmllVG9Db250ZW50IiwiY2hhbm5lbFJlc3VsdHMiLCJtYXBDaGFubmVsVG9Db250ZW50IiwidGh1bWJuYWlsIiwiY292ZXIiLCJlbmNvZGVVUklDb21wb25lbnQiLCJTdHJpbmciLCJ0aXRsZSIsImRlc2NyaXB0aW9uIiwicGxvdCIsInR5cGUiLCJnZW5yZSIsInllYXIiLCJiYWNrZHJvcCIsImJhY2tkcm9wX3BhdGgiLCJ1bmRlZmluZWQiLCJpbmZvIiwiZHVyYXRpb24iLCJzdHJlYW1faWNvbiIsIm1hcFNlcmllc0RldGFpbHNUb0NvbnRlbnQiLCJzZXJpZXNEZXRhaWxzIiwiZXBpc29kZXMiLCJlcGlzb2RlIiwiUFJPR1JFU1NfS0VZIiwic2F2ZUNvbnRlbnRQcm9ncmVzcyIsImNvbnRlbnRJZCIsImN1cnJlbnRUaW1lIiwicHJvZ3Jlc3NEYXRhIiwic2V0SXRlbSIsInN0cmluZ2lmeSIsImdldENvbnRlbnRDdXJyZW50VGltZSIsInByb2dyZXNzIiwidGVzdENvbm5lY3Rpb24iLCJnZXRFcnJvck1lc3NhZ2UiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/api-service.ts\n"));

/***/ })

});