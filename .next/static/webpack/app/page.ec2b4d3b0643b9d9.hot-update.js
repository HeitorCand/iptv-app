"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/api-service.ts":
/*!****************************!*\
  !*** ./lib/api-service.ts ***!
  \****************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ApiError: () => (/* binding */ ApiError),\n/* harmony export */   AuthenticationError: () => (/* binding */ AuthenticationError),\n/* harmony export */   NetworkError: () => (/* binding */ NetworkError),\n/* harmony export */   NotFoundError: () => (/* binding */ NotFoundError),\n/* harmony export */   getAllLiveStreams: () => (/* binding */ getAllLiveStreams),\n/* harmony export */   getAllMovies: () => (/* binding */ getAllMovies),\n/* harmony export */   getAllSeries: () => (/* binding */ getAllSeries),\n/* harmony export */   getContentCurrentTime: () => (/* binding */ getContentCurrentTime),\n/* harmony export */   getCredentials: () => (/* binding */ getCredentials),\n/* harmony export */   getErrorMessage: () => (/* binding */ getErrorMessage),\n/* harmony export */   getMovieInfo: () => (/* binding */ getMovieInfo),\n/* harmony export */   getSeriesInfo: () => (/* binding */ getSeriesInfo),\n/* harmony export */   getStreamUrl: () => (/* binding */ getStreamUrl),\n/* harmony export */   mapChannelToContent: () => (/* binding */ mapChannelToContent),\n/* harmony export */   mapMovieToContent: () => (/* binding */ mapMovieToContent),\n/* harmony export */   mapSeriesDetailsToContent: () => (/* binding */ mapSeriesDetailsToContent),\n/* harmony export */   mapSeriesToContent: () => (/* binding */ mapSeriesToContent),\n/* harmony export */   saveContentProgress: () => (/* binding */ saveContentProgress),\n/* harmony export */   searchContent: () => (/* binding */ searchContent),\n/* harmony export */   testConnection: () => (/* binding */ testConnection)\n/* harmony export */ });\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n// Update the ApiCredentials interface to include forceHttps\n// Custom error classes\nclass AuthenticationError extends Error {\n    constructor(message = \"Authentication failed\"){\n        super(message);\n        this.name = \"AuthenticationError\";\n    }\n}\nclass NotFoundError extends Error {\n    constructor(message = \"Resource not found\"){\n        super(message);\n        this.name = \"NotFoundError\";\n    }\n}\nclass ApiError extends Error {\n    constructor(message = \"API error\", statusCode){\n        super(message);\n        this.name = \"ApiError\";\n        this.statusCode = statusCode;\n    }\n}\nclass NetworkError extends Error {\n    constructor(message = \"Network error\"){\n        super(message);\n        this.name = \"NetworkError\";\n    }\n}\n// Update the getCredentials function to handle the forceHttps option\nconst getCredentials = ()=>{\n    if (false) {}\n    const storedConfig = localStorage.getItem(\"streamConfig\");\n    if (!storedConfig) return null;\n    try {\n        const credentials = JSON.parse(storedConfig);\n        // If forceHttps is enabled, ensure the URL uses HTTPS\n        if (credentials.forceHttps && credentials.apiUrl.toLowerCase().startsWith(\"http:\")) {\n            credentials.apiUrl = credentials.apiUrl.replace(/^http:/i, \"https:\");\n        }\n        return credentials;\n    } catch (error) {\n        console.error(\"Failed to parse stored credentials:\", error);\n        return null;\n    }\n};\n// Update the apiRequest function to better handle mixed content errors\nasync function apiRequest(endpoint) {\n    let params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, retries = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 2;\n    const credentials = getCredentials();\n    if (!credentials) {\n        throw new AuthenticationError(\"Credenciais não encontradas. Configure o aplicativo primeiro.\");\n    }\n    const { apiUrl, username, password } = credentials;\n    // Build URL with credentials and params\n    let url;\n    try {\n        url = new URL(apiUrl);\n    } catch (error) {\n        throw new Error(\"URL inv\\xe1lida: \".concat(apiUrl, \". Verifique a configura\\xe7\\xe3o.\"));\n    }\n    // Check for potential mixed content issues\n    if ( true && window.location.protocol === \"https:\" && url.protocol === \"http:\") {\n        console.warn(\"Potential mixed content issue: trying to load HTTP content in an HTTPS page\");\n    }\n    // Add authentication params and action\n    const queryParams = new URLSearchParams({\n        username,\n        password,\n        action: endpoint,\n        ...params\n    });\n    let fullUrl = \"\".concat(url.toString(), \"?\").concat(queryParams.toString());\n    try {\n        const response = await fetch(fullUrl, {\n            method: \"GET\",\n            mode: \"no-cors\",\n            credentials: \"omit\",\n            headers: {\n                \"accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7\",\n                \"accept-language\": \"pt-BR,pt;q=0.9,en-US;q=0.8,en;q=0.7\",\n                \"cache-control\": \"max-age=0\",\n                \"upgrade-insecure-requests\": \"1\",\n                \"Referer\": apiUrl,\n                \"sec-fetch-dest\": \"document\"\n            },\n            referrerPolicy: \"strict-origin-when-cross-origin\"\n        });\n        // Handle different HTTP status codes\n        if (!response.ok) {\n            if (response.status === 401 || response.status === 403) {\n                throw new AuthenticationError();\n            } else if (response.status === 404) {\n                throw new NotFoundError();\n            } else if (response.status === 500 && process.env.USE_PROXY !== \"true\") {\n                console.warn(\"Erro 500 detectado. Tentando novamente com proxy habilitado.\");\n                process.env.USE_PROXY = \"true\";\n                return apiRequest(endpoint, params, retries);\n            } else {\n                throw new ApiError(\"Erro na API: \".concat(response.statusText), response.status);\n            }\n        }\n        // Parse JSON response\n        try {\n            const data = await response.json();\n            // Some APIs return error information in the response body\n            if (data && data.error) {\n                throw new ApiError(\"Erro na API: \".concat(data.error));\n            }\n            return data;\n        } catch (error) {\n            throw new ApiError(\"Erro ao processar resposta da API. Formato inválido.\");\n        }\n    } catch (error) {\n        // Check specifically for mixed content errors\n        if (error instanceof TypeError) {\n            const errorMessage = error.message.toLowerCase();\n            if (errorMessage.includes(\"mixed content\") || errorMessage.includes(\"blocked\") && errorMessage.includes(\"insecure\")) {\n                throw new NetworkError(\"Erro de conteúdo misto: seu navegador bloqueou a requisição HTTP em um site HTTPS. \" + \"Tente ativar 'Forçar HTTPS' nas configurações ou use um servidor com HTTPS.\");\n            }\n            // Handle network errors and implement retry logic\n            if (errorMessage.includes(\"fetch\")) {\n                // Network error\n                if (retries > 0) {\n                    console.log(\"Retry attempt (\".concat(retries, \" remaining) for \").concat(fullUrl));\n                    // Exponential backoff: wait longer between retries\n                    await new Promise((resolve)=>setTimeout(resolve, (3 - retries) * 1000));\n                    return apiRequest(endpoint, params, retries - 1);\n                }\n                throw new NetworkError();\n            }\n        }\n        // Re-throw other errors\n        throw error;\n    }\n}\n// Update the getStreamUrl function to handle HTTPS\nconst getStreamUrl = (streamId, streamType, episodeId)=>{\n    const credentials = getCredentials();\n    if (!credentials) {\n        throw new AuthenticationError(\"Credenciais não encontradas. Configure o aplicativo primeiro.\");\n    }\n    const { apiUrl, username, password, forceHttps } = credentials;\n    let baseUrl = apiUrl.replace(\"player_api.php\", \"\");\n    // If forceHttps is enabled, ensure the URL uses HTTPS\n    if (forceHttps && baseUrl.toLowerCase().startsWith(\"http:\")) {\n        baseUrl = baseUrl.replace(/^http:/i, \"https:\");\n    }\n    if (streamType === \"live\") {\n        return \"\".concat(baseUrl, \"live/\").concat(username, \"/\").concat(password, \"/\").concat(streamId, \".ts\");\n    } else if (streamType === \"movie\") {\n        return \"\".concat(baseUrl, \"movie/\").concat(username, \"/\").concat(password, \"/\").concat(streamId, \".mp4\");\n    } else if (streamType === \"series\" && episodeId) {\n        return \"\".concat(baseUrl, \"series/\").concat(username, \"/\").concat(password, \"/\").concat(streamId, \"/\").concat(episodeId, \".mp4\");\n    }\n    throw new Error(\"Tipo de stream inválido ou ID de episódio ausente para séries\");\n};\n// API Endpoints and Data Mapping\nconst API_ENDPOINTS = {\n    GET_ALL_SERIES: \"get_series\",\n    GET_ALL_MOVIES: \"get_vod\",\n    GET_ALL_LIVE_STREAMS: \"get_live_streams\",\n    GET_SERIES_INFO: \"get_series_info\",\n    GET_MOVIE_INFO: \"get_vod_info\",\n    SEARCH: \"search\"\n};\n// API Calls\nconst getAllSeries = async ()=>{\n    const response = await apiRequest(\"get_series\");\n    return Object.entries(response.series || {}).map((param)=>{\n        let [id, series] = param;\n        return {\n            id,\n            ...series\n        };\n    });\n};\nconst getAllMovies = async ()=>{\n    const response = await apiRequest(\"get_vod\");\n    return Object.entries(response.vod || {}).map((param)=>{\n        let [id, movie] = param;\n        return {\n            id,\n            ...movie\n        };\n    });\n};\nconst getAllLiveStreams = async ()=>{\n    const response = await apiRequest(\"get_live_streams\");\n    return Object.entries(response.live || {}).map((param)=>{\n        let [id, channel] = param;\n        return {\n            id,\n            ...channel\n        };\n    });\n};\nconst getSeriesInfo = async (seriesId)=>{\n    const response = await apiRequest(API_ENDPOINTS.GET_SERIES_INFO, {\n        series_id: seriesId\n    });\n    return response;\n};\nconst getMovieInfo = async (vodId)=>{\n    const response = await apiRequest(API_ENDPOINTS.GET_MOVIE_INFO, {\n        vod_id: vodId\n    });\n    return response;\n};\nconst searchContent = async (query)=>{\n    try {\n        const response = await apiRequest(API_ENDPOINTS.SEARCH, {\n            query: query\n        });\n        if (!response || !response.data) {\n            return [];\n        }\n        const seriesResults = Object.entries(response.data.series || {}).map((param)=>{\n            let [id, series] = param;\n            return mapSeriesToContent({\n                id,\n                ...series\n            });\n        });\n        const movieResults = Object.entries(response.data.vod || {}).map((param)=>{\n            let [id, movie] = param;\n            return mapMovieToContent({\n                id,\n                ...movie\n            });\n        });\n        const channelResults = Object.entries(response.data.live || {}).map((param)=>{\n            let [id, channel] = param;\n            return mapChannelToContent({\n                id,\n                ...channel\n            });\n        });\n        return [\n            ...seriesResults,\n            ...movieResults,\n            ...channelResults\n        ];\n    } catch (error) {\n        console.error(\"Search failed:\", error);\n        return [];\n    }\n};\n// Data Mapping Functions\nconst mapSeriesToContent = (series)=>({\n        id: series.id,\n        title: series.name,\n        description: series.plot,\n        thumbnail: series.cover,\n        type: \"series\",\n        genre: series.genre,\n        year: series.year\n    });\nconst mapMovieToContent = (movie)=>({\n        id: movie.id,\n        title: movie.name,\n        description: movie.plot,\n        thumbnail: movie.cover,\n        type: \"movie\",\n        genre: movie.genre,\n        year: movie.year,\n        duration: movie.duration\n    });\nconst mapChannelToContent = (channel)=>({\n        id: channel.id,\n        title: channel.name,\n        description: \"\",\n        thumbnail: channel.stream_icon,\n        type: \"channel\"\n    });\nconst mapSeriesDetailsToContent = (seriesDetails)=>{\n    const series = seriesDetails.info;\n    const episodes = Object.entries(seriesDetails.episodes || {}).map((param)=>{\n        let [episodeId, episode] = param;\n        return {\n            id: episodeId,\n            title: episode.title,\n            description: episode.plot,\n            duration: episode.duration\n        };\n    });\n    return {\n        id: series.id,\n        title: series.name,\n        description: series.plot,\n        thumbnail: series.cover,\n        type: \"series\",\n        genre: series.genre,\n        year: series.year,\n        episodes: episodes\n    };\n};\n// Local Storage Functions\nconst PROGRESS_KEY = \"contentProgress\";\nconst saveContentProgress = (contentId, currentTime, duration, episodeId)=>{\n    if (false) {}\n    try {\n        const progressData = JSON.parse(localStorage.getItem(PROGRESS_KEY) || \"{}\");\n        progressData[contentId + (episodeId ? \"_\".concat(episodeId) : \"\")] = {\n            currentTime,\n            duration\n        };\n        localStorage.setItem(PROGRESS_KEY, JSON.stringify(progressData));\n    } catch (error) {\n        console.error(\"Failed to save content progress:\", error);\n    }\n};\nconst getContentCurrentTime = (contentId, episodeId)=>{\n    if (false) {}\n    try {\n        const progressData = JSON.parse(localStorage.getItem(PROGRESS_KEY) || \"{}\");\n        const progress = progressData[contentId + (episodeId ? \"_\".concat(episodeId) : \"\")];\n        return progress ? progress.currentTime : null;\n    } catch (error) {\n        console.error(\"Failed to get content progress:\", error);\n        return null;\n    }\n};\n// Test Connection\nconst testConnection = async ()=>{\n    try {\n        // Attempt to fetch series (a basic API call)\n        await getAllSeries();\n        return true;\n    } catch (error) {\n        console.error(\"Connection test failed:\", error);\n        return false;\n    }\n};\n// Error Message Helper\nconst getErrorMessage = (error)=>{\n    if (error instanceof AuthenticationError) {\n        return \"Falha na autenticação. Verifique suas credenciais.\";\n    } else if (error instanceof NotFoundError) {\n        return \"Recurso não encontrado.\";\n    } else if (error instanceof ApiError) {\n        return \"Erro na API: \".concat(error.message);\n    } else if (error instanceof NetworkError) {\n        return \"Erro de rede. Verifique sua conexão com a internet.\";\n    } else if (error instanceof TypeError && error.message.includes(\"Failed to fetch\")) {\n        return \"Erro ao conectar ao servidor. Verifique a URL e sua conexão.\";\n    } else {\n        return \"Ocorreu um erro inesperado.\";\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LEVBQUUsT0FBT3BELE9BQU87UUFDZEMsUUFBUUQsS0FBSyxDQUFDLDJCQUEyQkE7UUFDekMsT0FBTztJQUNUO0FBQ0YsRUFBQztBQUVELHVCQUF1QjtBQUNoQixNQUFNdUcsa0JBQWtCLENBQUN2RztJQUM5QixJQUFJQSxpQkFBaUJyQixxQkFBcUI7UUFDeEMsT0FBTztJQUNULE9BQU8sSUFBSXFCLGlCQUFpQmhCLGVBQWU7UUFDekMsT0FBTztJQUNULE9BQU8sSUFBSWdCLGlCQUFpQmYsVUFBVTtRQUNwQyxPQUFPLGdCQUE4QixPQUFkZSxNQUFNbEIsT0FBTztJQUN0QyxPQUFPLElBQUlrQixpQkFBaUJiLGNBQWM7UUFDeEMsT0FBTztJQUNULE9BQU8sSUFBSWEsaUJBQWlCaUMsYUFBYWpDLE1BQU1sQixPQUFPLENBQUNxRCxRQUFRLENBQUMsb0JBQW9CO1FBQ2xGLE9BQU87SUFDVCxPQUFPO1FBQ0wsT0FBTztJQUNUO0FBQ0YsRUFBQyIsInNvdXJjZXMiOlsiL1VzZXJzL2hlaXRvci5jYW5kaWRvL0RvY3VtZW50cy9pcHR2L2lwdHYtYXBwL2xpYi9hcGktc2VydmljZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBVcGRhdGUgdGhlIEFwaUNyZWRlbnRpYWxzIGludGVyZmFjZSB0byBpbmNsdWRlIGZvcmNlSHR0cHNcbmV4cG9ydCBpbnRlcmZhY2UgQXBpQ3JlZGVudGlhbHMge1xuICBhcGlVcmw6IHN0cmluZ1xuICB1c2VybmFtZTogc3RyaW5nXG4gIHBhc3N3b3JkOiBzdHJpbmdcbiAgZm9yY2VIdHRwcz86IGJvb2xlYW5cbn1cblxuLy8gQ3VzdG9tIGVycm9yIGNsYXNzZXNcbmV4cG9ydCBjbGFzcyBBdXRoZW50aWNhdGlvbkVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlID0gXCJBdXRoZW50aWNhdGlvbiBmYWlsZWRcIikge1xuICAgIHN1cGVyKG1lc3NhZ2UpXG4gICAgdGhpcy5uYW1lID0gXCJBdXRoZW50aWNhdGlvbkVycm9yXCJcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgTm90Rm91bmRFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSA9IFwiUmVzb3VyY2Ugbm90IGZvdW5kXCIpIHtcbiAgICBzdXBlcihtZXNzYWdlKVxuICAgIHRoaXMubmFtZSA9IFwiTm90Rm91bmRFcnJvclwiXG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIEFwaUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBwdWJsaWMgc3RhdHVzQ29kZTogbnVtYmVyIHwgdW5kZWZpbmVkXG5cbiAgY29uc3RydWN0b3IobWVzc2FnZSA9IFwiQVBJIGVycm9yXCIsIHN0YXR1c0NvZGU/OiBudW1iZXIpIHtcbiAgICBzdXBlcihtZXNzYWdlKVxuICAgIHRoaXMubmFtZSA9IFwiQXBpRXJyb3JcIlxuICAgIHRoaXMuc3RhdHVzQ29kZSA9IHN0YXR1c0NvZGVcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgTmV0d29ya0Vycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlID0gXCJOZXR3b3JrIGVycm9yXCIpIHtcbiAgICBzdXBlcihtZXNzYWdlKVxuICAgIHRoaXMubmFtZSA9IFwiTmV0d29ya0Vycm9yXCJcbiAgfVxufVxuXG4vLyBVcGRhdGUgdGhlIGdldENyZWRlbnRpYWxzIGZ1bmN0aW9uIHRvIGhhbmRsZSB0aGUgZm9yY2VIdHRwcyBvcHRpb25cbmV4cG9ydCBjb25zdCBnZXRDcmVkZW50aWFscyA9ICgpOiBBcGlDcmVkZW50aWFscyB8IG51bGwgPT4ge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuIG51bGxcblxuICBjb25zdCBzdG9yZWRDb25maWcgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShcInN0cmVhbUNvbmZpZ1wiKVxuICBpZiAoIXN0b3JlZENvbmZpZykgcmV0dXJuIG51bGxcblxuICB0cnkge1xuICAgIGNvbnN0IGNyZWRlbnRpYWxzID0gSlNPTi5wYXJzZShzdG9yZWRDb25maWcpIGFzIEFwaUNyZWRlbnRpYWxzXG5cbiAgICAvLyBJZiBmb3JjZUh0dHBzIGlzIGVuYWJsZWQsIGVuc3VyZSB0aGUgVVJMIHVzZXMgSFRUUFNcbiAgICBpZiAoY3JlZGVudGlhbHMuZm9yY2VIdHRwcyAmJiBjcmVkZW50aWFscy5hcGlVcmwudG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKFwiaHR0cDpcIikpIHtcbiAgICAgIGNyZWRlbnRpYWxzLmFwaVVybCA9IGNyZWRlbnRpYWxzLmFwaVVybC5yZXBsYWNlKC9eaHR0cDovaSwgXCJodHRwczpcIilcbiAgICB9XG5cbiAgICByZXR1cm4gY3JlZGVudGlhbHNcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIHBhcnNlIHN0b3JlZCBjcmVkZW50aWFsczpcIiwgZXJyb3IpXG4gICAgcmV0dXJuIG51bGxcbiAgfVxufVxuXG4vLyBVcGRhdGUgdGhlIGFwaVJlcXVlc3QgZnVuY3Rpb24gdG8gYmV0dGVyIGhhbmRsZSBtaXhlZCBjb250ZW50IGVycm9yc1xuYXN5bmMgZnVuY3Rpb24gYXBpUmVxdWVzdDxUPihlbmRwb2ludDogc3RyaW5nLCBwYXJhbXM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7fSwgcmV0cmllcyA9IDIpOiBQcm9taXNlPFQ+IHtcbiAgY29uc3QgY3JlZGVudGlhbHMgPSBnZXRDcmVkZW50aWFscygpXG4gIGlmICghY3JlZGVudGlhbHMpIHtcbiAgICB0aHJvdyBuZXcgQXV0aGVudGljYXRpb25FcnJvcihcIkNyZWRlbmNpYWlzIG7Do28gZW5jb250cmFkYXMuIENvbmZpZ3VyZSBvIGFwbGljYXRpdm8gcHJpbWVpcm8uXCIpXG4gIH1cblxuICBjb25zdCB7IGFwaVVybCwgdXNlcm5hbWUsIHBhc3N3b3JkIH0gPSBjcmVkZW50aWFsc1xuXG4gIC8vIEJ1aWxkIFVSTCB3aXRoIGNyZWRlbnRpYWxzIGFuZCBwYXJhbXNcbiAgbGV0IHVybDogVVJMXG4gIHRyeSB7XG4gICAgdXJsID0gbmV3IFVSTChhcGlVcmwpXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVUkwgaW52w6FsaWRhOiAke2FwaVVybH0uIFZlcmlmaXF1ZSBhIGNvbmZpZ3VyYcOnw6NvLmApXG4gIH1cblxuICAvLyBDaGVjayBmb3IgcG90ZW50aWFsIG1peGVkIGNvbnRlbnQgaXNzdWVzXG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbCA9PT0gXCJodHRwczpcIiAmJiB1cmwucHJvdG9jb2wgPT09IFwiaHR0cDpcIikge1xuICAgIGNvbnNvbGUud2FybihcIlBvdGVudGlhbCBtaXhlZCBjb250ZW50IGlzc3VlOiB0cnlpbmcgdG8gbG9hZCBIVFRQIGNvbnRlbnQgaW4gYW4gSFRUUFMgcGFnZVwiKVxuICB9XG5cbiAgLy8gQWRkIGF1dGhlbnRpY2F0aW9uIHBhcmFtcyBhbmQgYWN0aW9uXG4gIGNvbnN0IHF1ZXJ5UGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh7XG4gICAgdXNlcm5hbWUsXG4gICAgcGFzc3dvcmQsXG4gICAgYWN0aW9uOiBlbmRwb2ludCwgLy8gQWRkIHRoZSBhY3Rpb24gcGFyYW1ldGVyIGhlcmVcbiAgICAuLi5wYXJhbXMsXG4gIH0pXG5cbiAgbGV0IGZ1bGxVcmwgPSBgJHt1cmwudG9TdHJpbmcoKX0/JHtxdWVyeVBhcmFtcy50b1N0cmluZygpfWBcblxuICB0cnkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goZnVsbFVybCwge1xuICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgbW9kZTogXCJuby1jb3JzXCIsXG4gICAgICBjcmVkZW50aWFsczogXCJvbWl0XCIsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICBcImFjY2VwdFwiOiBcInRleHQvaHRtbCxhcHBsaWNhdGlvbi94aHRtbCt4bWwsYXBwbGljYXRpb24veG1sO3E9MC45LGltYWdlL2F2aWYsaW1hZ2Uvd2VicCxpbWFnZS9hcG5nLCovKjtxPTAuOCxhcHBsaWNhdGlvbi9zaWduZWQtZXhjaGFuZ2U7dj1iMztxPTAuN1wiLFxuICAgICAgXCJhY2NlcHQtbGFuZ3VhZ2VcIjogXCJwdC1CUixwdDtxPTAuOSxlbi1VUztxPTAuOCxlbjtxPTAuN1wiLFxuICAgICAgXCJjYWNoZS1jb250cm9sXCI6IFwibWF4LWFnZT0wXCIsXG4gICAgICBcInVwZ3JhZGUtaW5zZWN1cmUtcmVxdWVzdHNcIjogXCIxXCIsXG4gICAgICBcIlJlZmVyZXJcIjogYXBpVXJsLFxuICAgICAgXCJzZWMtZmV0Y2gtZGVzdFwiOiBcImRvY3VtZW50XCIsXG4gICAgICB9LFxuICAgICAgcmVmZXJyZXJQb2xpY3k6IFwic3RyaWN0LW9yaWdpbi13aGVuLWNyb3NzLW9yaWdpblwiLFxuICAgIH0pXG5cblxuICAgIC8vIEhhbmRsZSBkaWZmZXJlbnQgSFRUUCBzdGF0dXMgY29kZXNcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MDEgfHwgcmVzcG9uc2Uuc3RhdHVzID09PSA0MDMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEF1dGhlbnRpY2F0aW9uRXJyb3IoKVxuICAgICAgfSBlbHNlIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQwNCkge1xuICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFcnJvcigpXG4gICAgICB9IGVsc2UgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNTAwICYmIHByb2Nlc3MuZW52LlVTRV9QUk9YWSAhPT0gXCJ0cnVlXCIpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiRXJybyA1MDAgZGV0ZWN0YWRvLiBUZW50YW5kbyBub3ZhbWVudGUgY29tIHByb3h5IGhhYmlsaXRhZG8uXCIpXG4gICAgICAgIHByb2Nlc3MuZW52LlVTRV9QUk9YWSA9IFwidHJ1ZVwiXG4gICAgICAgIHJldHVybiBhcGlSZXF1ZXN0PFQ+KGVuZHBvaW50LCBwYXJhbXMsIHJldHJpZXMpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgQXBpRXJyb3IoYEVycm8gbmEgQVBJOiAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCwgcmVzcG9uc2Uuc3RhdHVzKVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFBhcnNlIEpTT04gcmVzcG9uc2VcbiAgICB0cnkge1xuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKVxuXG4gICAgICAvLyBTb21lIEFQSXMgcmV0dXJuIGVycm9yIGluZm9ybWF0aW9uIGluIHRoZSByZXNwb25zZSBib2R5XG4gICAgICBpZiAoZGF0YSAmJiBkYXRhLmVycm9yKSB7XG4gICAgICAgIHRocm93IG5ldyBBcGlFcnJvcihgRXJybyBuYSBBUEk6ICR7ZGF0YS5lcnJvcn1gKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGF0YSBhcyBUXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBBcGlFcnJvcihcIkVycm8gYW8gcHJvY2Vzc2FyIHJlc3Bvc3RhIGRhIEFQSS4gRm9ybWF0byBpbnbDoWxpZG8uXCIpXG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIC8vIENoZWNrIHNwZWNpZmljYWxseSBmb3IgbWl4ZWQgY29udGVudCBlcnJvcnNcbiAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBUeXBlRXJyb3IpIHtcbiAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IGVycm9yLm1lc3NhZ2UudG9Mb3dlckNhc2UoKVxuXG4gICAgICBpZiAoXG4gICAgICAgIGVycm9yTWVzc2FnZS5pbmNsdWRlcyhcIm1peGVkIGNvbnRlbnRcIikgfHxcbiAgICAgICAgKGVycm9yTWVzc2FnZS5pbmNsdWRlcyhcImJsb2NrZWRcIikgJiYgZXJyb3JNZXNzYWdlLmluY2x1ZGVzKFwiaW5zZWN1cmVcIikpXG4gICAgICApIHtcbiAgICAgICAgdGhyb3cgbmV3IE5ldHdvcmtFcnJvcihcbiAgICAgICAgICBcIkVycm8gZGUgY29udGXDumRvIG1pc3RvOiBzZXUgbmF2ZWdhZG9yIGJsb3F1ZW91IGEgcmVxdWlzacOnw6NvIEhUVFAgZW0gdW0gc2l0ZSBIVFRQUy4gXCIgK1xuICAgICAgICAgICAgXCJUZW50ZSBhdGl2YXIgJ0ZvcsOnYXIgSFRUUFMnIG5hcyBjb25maWd1cmHDp8O1ZXMgb3UgdXNlIHVtIHNlcnZpZG9yIGNvbSBIVFRQUy5cIixcbiAgICAgICAgKVxuICAgICAgfVxuXG4gICAgICAvLyBIYW5kbGUgbmV0d29yayBlcnJvcnMgYW5kIGltcGxlbWVudCByZXRyeSBsb2dpY1xuICAgICAgaWYgKGVycm9yTWVzc2FnZS5pbmNsdWRlcyhcImZldGNoXCIpKSB7XG4gICAgICAgIC8vIE5ldHdvcmsgZXJyb3JcbiAgICAgICAgaWYgKHJldHJpZXMgPiAwKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coYFJldHJ5IGF0dGVtcHQgKCR7cmV0cmllc30gcmVtYWluaW5nKSBmb3IgJHtmdWxsVXJsfWApXG4gICAgICAgICAgLy8gRXhwb25lbnRpYWwgYmFja29mZjogd2FpdCBsb25nZXIgYmV0d2VlbiByZXRyaWVzXG4gICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgKDMgLSByZXRyaWVzKSAqIDEwMDApKVxuICAgICAgICAgIHJldHVybiBhcGlSZXF1ZXN0PFQ+KGVuZHBvaW50LCBwYXJhbXMsIHJldHJpZXMgLSAxKVxuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBOZXR3b3JrRXJyb3IoKVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJlLXRocm93IG90aGVyIGVycm9yc1xuICAgIHRocm93IGVycm9yXG4gIH1cbn1cblxuLy8gVXBkYXRlIHRoZSBnZXRTdHJlYW1VcmwgZnVuY3Rpb24gdG8gaGFuZGxlIEhUVFBTXG5leHBvcnQgY29uc3QgZ2V0U3RyZWFtVXJsID0gKHN0cmVhbUlkOiBzdHJpbmcsIHN0cmVhbVR5cGU6IFwibGl2ZVwiIHwgXCJtb3ZpZVwiIHwgXCJzZXJpZXNcIiwgZXBpc29kZUlkPzogc3RyaW5nKTogc3RyaW5nID0+IHtcbiAgY29uc3QgY3JlZGVudGlhbHMgPSBnZXRDcmVkZW50aWFscygpXG4gIGlmICghY3JlZGVudGlhbHMpIHtcbiAgICB0aHJvdyBuZXcgQXV0aGVudGljYXRpb25FcnJvcihcIkNyZWRlbmNpYWlzIG7Do28gZW5jb250cmFkYXMuIENvbmZpZ3VyZSBvIGFwbGljYXRpdm8gcHJpbWVpcm8uXCIpXG4gIH1cblxuICBjb25zdCB7IGFwaVVybCwgdXNlcm5hbWUsIHBhc3N3b3JkLCBmb3JjZUh0dHBzIH0gPSBjcmVkZW50aWFsc1xuICBsZXQgYmFzZVVybCA9IGFwaVVybC5yZXBsYWNlKFwicGxheWVyX2FwaS5waHBcIiwgXCJcIilcblxuICAvLyBJZiBmb3JjZUh0dHBzIGlzIGVuYWJsZWQsIGVuc3VyZSB0aGUgVVJMIHVzZXMgSFRUUFNcbiAgaWYgKGZvcmNlSHR0cHMgJiYgYmFzZVVybC50b0xvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgoXCJodHRwOlwiKSkge1xuICAgIGJhc2VVcmwgPSBiYXNlVXJsLnJlcGxhY2UoL15odHRwOi9pLCBcImh0dHBzOlwiKVxuICB9XG5cbiAgaWYgKHN0cmVhbVR5cGUgPT09IFwibGl2ZVwiKSB7XG4gICAgcmV0dXJuIGAke2Jhc2VVcmx9bGl2ZS8ke3VzZXJuYW1lfS8ke3Bhc3N3b3JkfS8ke3N0cmVhbUlkfS50c2BcbiAgfSBlbHNlIGlmIChzdHJlYW1UeXBlID09PSBcIm1vdmllXCIpIHtcbiAgICByZXR1cm4gYCR7YmFzZVVybH1tb3ZpZS8ke3VzZXJuYW1lfS8ke3Bhc3N3b3JkfS8ke3N0cmVhbUlkfS5tcDRgXG4gIH0gZWxzZSBpZiAoc3RyZWFtVHlwZSA9PT0gXCJzZXJpZXNcIiAmJiBlcGlzb2RlSWQpIHtcbiAgICByZXR1cm4gYCR7YmFzZVVybH1zZXJpZXMvJHt1c2VybmFtZX0vJHtwYXNzd29yZH0vJHtzdHJlYW1JZH0vJHtlcGlzb2RlSWR9Lm1wNGBcbiAgfVxuXG4gIHRocm93IG5ldyBFcnJvcihcIlRpcG8gZGUgc3RyZWFtIGludsOhbGlkbyBvdSBJRCBkZSBlcGlzw7NkaW8gYXVzZW50ZSBwYXJhIHPDqXJpZXNcIilcbn1cblxuLy8gQVBJIEVuZHBvaW50cyBhbmQgRGF0YSBNYXBwaW5nXG5jb25zdCBBUElfRU5EUE9JTlRTID0ge1xuICBHRVRfQUxMX1NFUklFUzogXCJnZXRfc2VyaWVzXCIsXG4gIEdFVF9BTExfTU9WSUVTOiBcImdldF92b2RcIixcbiAgR0VUX0FMTF9MSVZFX1NUUkVBTVM6IFwiZ2V0X2xpdmVfc3RyZWFtc1wiLFxuICBHRVRfU0VSSUVTX0lORk86IFwiZ2V0X3Nlcmllc19pbmZvXCIsXG4gIEdFVF9NT1ZJRV9JTkZPOiBcImdldF92b2RfaW5mb1wiLFxuICBTRUFSQ0g6IFwic2VhcmNoXCIsXG59XG5cbmludGVyZmFjZSBBcGlSZXNwb25zZTxUPiB7XG4gIHN0YXR1czogYm9vbGVhblxuICBkYXRhOiBUXG4gIGVycm9yPzogc3RyaW5nXG59XG5cbi8vIERhdGEgVHlwZXNcbmV4cG9ydCBpbnRlcmZhY2UgQ29udGVudEl0ZW0ge1xuICBpZDogc3RyaW5nXG4gIHRpdGxlOiBzdHJpbmdcbiAgZGVzY3JpcHRpb246IHN0cmluZ1xuICB0aHVtYm5haWw6IHN0cmluZ1xuICBiYWNrZHJvcD86IHN0cmluZ1xuICB0eXBlOiBcInNlcmllc1wiIHwgXCJtb3ZpZVwiIHwgXCJjaGFubmVsXCJcbiAgZ2VucmU/OiBzdHJpbmdcbiAgeWVhcj86IHN0cmluZ1xuICBkdXJhdGlvbj86IHN0cmluZ1xuICBwcm9ncmVzcz86IG51bWJlclxuICBlcGlzb2Rlcz86IEVwaXNvZGVbXVxuICBpbmZvPzogYW55XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRXBpc29kZSB7XG4gIGlkOiBzdHJpbmdcbiAgdGl0bGU6IHN0cmluZ1xuICBkZXNjcmlwdGlvbjogc3RyaW5nXG4gIHRodW1ibmFpbD86IHN0cmluZ1xuICBkdXJhdGlvbj86IHN0cmluZ1xuICBwcm9ncmVzcz86IG51bWJlclxufVxuXG5pbnRlcmZhY2UgU2VyaWVzUmVzcG9uc2Uge1xuICBzZXJpZXM6IHtcbiAgICBbc2VyaWVzSWQ6IHN0cmluZ106IHtcbiAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgY292ZXI6IHN0cmluZ1xuICAgICAgcGxvdDogc3RyaW5nXG4gICAgICBnZW5yZTogc3RyaW5nXG4gICAgICB5ZWFyOiBzdHJpbmdcbiAgICAgIGVwaXNvZGVfZGV0YWlsczoge1xuICAgICAgICBbZXBpc29kZUlkOiBzdHJpbmddOiB7XG4gICAgICAgICAgdGl0bGU6IHN0cmluZ1xuICAgICAgICAgIHBsb3Q6IHN0cmluZ1xuICAgICAgICAgIGVwaXNvZGVfbnVtOiBzdHJpbmdcbiAgICAgICAgICBzZWFzb25fbnVtOiBzdHJpbmdcbiAgICAgICAgICBkdXJhdGlvbjogc3RyaW5nXG4gICAgICAgICAgY3VzdG9tX3NpZDogc3RyaW5nXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuaW50ZXJmYWNlIE1vdmllUmVzcG9uc2Uge1xuICB2b2Q6IHtcbiAgICBbbW92aWVJZDogc3RyaW5nXToge1xuICAgICAgbmFtZTogc3RyaW5nXG4gICAgICBjb3Zlcjogc3RyaW5nXG4gICAgICBwbG90OiBzdHJpbmdcbiAgICAgIGdlbnJlOiBzdHJpbmdcbiAgICAgIHllYXI6IHN0cmluZ1xuICAgICAgZHVyYXRpb246IHN0cmluZ1xuICAgIH1cbiAgfVxufVxuXG5pbnRlcmZhY2UgTGl2ZVN0cmVhbVJlc3BvbnNlIHtcbiAgbGl2ZToge1xuICAgIFtjaGFubmVsSWQ6IHN0cmluZ106IHtcbiAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgc3RyZWFtX2ljb246IHN0cmluZ1xuICAgICAgZXBnX2NoYW5uZWxfaWQ6IHN0cmluZ1xuICAgIH1cbiAgfVxufVxuXG4vLyBBUEkgQ2FsbHNcbmV4cG9ydCBjb25zdCBnZXRBbGxTZXJpZXMgPSBhc3luYyAoKTogUHJvbWlzZTxhbnlbXT4gPT4ge1xuICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaVJlcXVlc3Q8YW55PihcImdldF9zZXJpZXNcIilcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3BvbnNlLnNlcmllcyB8fCB7fSkubWFwKChbaWQsIHNlcmllc10pID0+ICh7IGlkLCAuLi5zZXJpZXMgfSkpXG59XG5cbmV4cG9ydCBjb25zdCBnZXRBbGxNb3ZpZXMgPSBhc3luYyAoKTogUHJvbWlzZTxhbnlbXT4gPT4ge1xuICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaVJlcXVlc3Q8YW55PihcImdldF92b2RcIilcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3BvbnNlLnZvZCB8fCB7fSkubWFwKChbaWQsIG1vdmllXSkgPT4gKHsgaWQsIC4uLm1vdmllIH0pKVxufVxuXG5leHBvcnQgY29uc3QgZ2V0QWxsTGl2ZVN0cmVhbXMgPSBhc3luYyAoKTogUHJvbWlzZTxhbnlbXT4gPT4ge1xuICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaVJlcXVlc3Q8YW55PihcImdldF9saXZlX3N0cmVhbXNcIilcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJlc3BvbnNlLmxpdmUgfHwge30pLm1hcCgoW2lkLCBjaGFubmVsXSkgPT4gKHsgaWQsIC4uLmNoYW5uZWwgfSkpXG59XG5cbmV4cG9ydCBjb25zdCBnZXRTZXJpZXNJbmZvID0gYXN5bmMgKHNlcmllc0lkOiBzdHJpbmcpOiBQcm9taXNlPGFueT4gPT4ge1xuICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaVJlcXVlc3Q8YW55PihBUElfRU5EUE9JTlRTLkdFVF9TRVJJRVNfSU5GTywgeyBzZXJpZXNfaWQ6IHNlcmllc0lkIH0pXG4gIHJldHVybiByZXNwb25zZVxufVxuXG5leHBvcnQgY29uc3QgZ2V0TW92aWVJbmZvID0gYXN5bmMgKHZvZElkOiBzdHJpbmcpOiBQcm9taXNlPGFueT4gPT4ge1xuICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaVJlcXVlc3Q8YW55PihBUElfRU5EUE9JTlRTLkdFVF9NT1ZJRV9JTkZPLCB7IHZvZF9pZDogdm9kSWQgfSlcbiAgcmV0dXJuIHJlc3BvbnNlXG59XG5cbmV4cG9ydCBjb25zdCBzZWFyY2hDb250ZW50ID0gYXN5bmMgKHF1ZXJ5OiBzdHJpbmcpOiBQcm9taXNlPENvbnRlbnRJdGVtW10+ID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaVJlcXVlc3Q8YW55PihBUElfRU5EUE9JTlRTLlNFQVJDSCwgeyBxdWVyeTogcXVlcnkgfSlcblxuICAgIGlmICghcmVzcG9uc2UgfHwgIXJlc3BvbnNlLmRhdGEpIHtcbiAgICAgIHJldHVybiBbXVxuICAgIH1cblxuICAgIGNvbnN0IHNlcmllc1Jlc3VsdHMgPSBPYmplY3QuZW50cmllcyhyZXNwb25zZS5kYXRhLnNlcmllcyB8fCB7fSkubWFwKChbaWQsIHNlcmllc10pID0+XG4gICAgICBtYXBTZXJpZXNUb0NvbnRlbnQoeyBpZCwgLi4uc2VyaWVzIH0pLFxuICAgIClcbiAgICBjb25zdCBtb3ZpZVJlc3VsdHMgPSBPYmplY3QuZW50cmllcyhyZXNwb25zZS5kYXRhLnZvZCB8fCB7fSkubWFwKChbaWQsIG1vdmllXSkgPT5cbiAgICAgIG1hcE1vdmllVG9Db250ZW50KHsgaWQsIC4uLm1vdmllIH0pLFxuICAgIClcbiAgICBjb25zdCBjaGFubmVsUmVzdWx0cyA9IE9iamVjdC5lbnRyaWVzKHJlc3BvbnNlLmRhdGEubGl2ZSB8fCB7fSkubWFwKChbaWQsIGNoYW5uZWxdKSA9PlxuICAgICAgbWFwQ2hhbm5lbFRvQ29udGVudCh7IGlkLCAuLi5jaGFubmVsIH0pLFxuICAgIClcblxuICAgIHJldHVybiBbLi4uc2VyaWVzUmVzdWx0cywgLi4ubW92aWVSZXN1bHRzLCAuLi5jaGFubmVsUmVzdWx0c11cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiU2VhcmNoIGZhaWxlZDpcIiwgZXJyb3IpXG4gICAgcmV0dXJuIFtdXG4gIH1cbn1cblxuLy8gRGF0YSBNYXBwaW5nIEZ1bmN0aW9uc1xuZXhwb3J0IGNvbnN0IG1hcFNlcmllc1RvQ29udGVudCA9IChzZXJpZXM6IGFueSk6IENvbnRlbnRJdGVtID0+ICh7XG4gIGlkOiBzZXJpZXMuaWQsXG4gIHRpdGxlOiBzZXJpZXMubmFtZSxcbiAgZGVzY3JpcHRpb246IHNlcmllcy5wbG90LFxuICB0aHVtYm5haWw6IHNlcmllcy5jb3ZlcixcbiAgdHlwZTogXCJzZXJpZXNcIixcbiAgZ2VucmU6IHNlcmllcy5nZW5yZSxcbiAgeWVhcjogc2VyaWVzLnllYXIsXG59KVxuXG5leHBvcnQgY29uc3QgbWFwTW92aWVUb0NvbnRlbnQgPSAobW92aWU6IGFueSk6IENvbnRlbnRJdGVtID0+ICh7XG4gIGlkOiBtb3ZpZS5pZCxcbiAgdGl0bGU6IG1vdmllLm5hbWUsXG4gIGRlc2NyaXB0aW9uOiBtb3ZpZS5wbG90LFxuICB0aHVtYm5haWw6IG1vdmllLmNvdmVyLFxuICB0eXBlOiBcIm1vdmllXCIsXG4gIGdlbnJlOiBtb3ZpZS5nZW5yZSxcbiAgeWVhcjogbW92aWUueWVhcixcbiAgZHVyYXRpb246IG1vdmllLmR1cmF0aW9uLFxufSlcblxuZXhwb3J0IGNvbnN0IG1hcENoYW5uZWxUb0NvbnRlbnQgPSAoY2hhbm5lbDogYW55KTogQ29udGVudEl0ZW0gPT4gKHtcbiAgaWQ6IGNoYW5uZWwuaWQsXG4gIHRpdGxlOiBjaGFubmVsLm5hbWUsXG4gIGRlc2NyaXB0aW9uOiBcIlwiLFxuICB0aHVtYm5haWw6IGNoYW5uZWwuc3RyZWFtX2ljb24sXG4gIHR5cGU6IFwiY2hhbm5lbFwiLFxufSlcblxuZXhwb3J0IGNvbnN0IG1hcFNlcmllc0RldGFpbHNUb0NvbnRlbnQgPSAoc2VyaWVzRGV0YWlsczogYW55KTogQ29udGVudEl0ZW0gPT4ge1xuICBjb25zdCBzZXJpZXMgPSBzZXJpZXNEZXRhaWxzLmluZm9cbiAgY29uc3QgZXBpc29kZXM6IEVwaXNvZGVbXSA9IE9iamVjdC5lbnRyaWVzKHNlcmllc0RldGFpbHMuZXBpc29kZXMgfHwge30pLm1hcChcbiAgICAoW2VwaXNvZGVJZCwgZXBpc29kZV06IFtzdHJpbmcsIGFueV0pID0+ICh7XG4gICAgICBpZDogZXBpc29kZUlkLFxuICAgICAgdGl0bGU6IGVwaXNvZGUudGl0bGUsXG4gICAgICBkZXNjcmlwdGlvbjogZXBpc29kZS5wbG90LFxuICAgICAgZHVyYXRpb246IGVwaXNvZGUuZHVyYXRpb24sXG4gICAgfSksXG4gIClcblxuICByZXR1cm4ge1xuICAgIGlkOiBzZXJpZXMuaWQsXG4gICAgdGl0bGU6IHNlcmllcy5uYW1lLFxuICAgIGRlc2NyaXB0aW9uOiBzZXJpZXMucGxvdCxcbiAgICB0aHVtYm5haWw6IHNlcmllcy5jb3ZlcixcbiAgICB0eXBlOiBcInNlcmllc1wiLFxuICAgIGdlbnJlOiBzZXJpZXMuZ2VucmUsXG4gICAgeWVhcjogc2VyaWVzLnllYXIsXG4gICAgZXBpc29kZXM6IGVwaXNvZGVzLFxuICB9XG59XG5cbi8vIExvY2FsIFN0b3JhZ2UgRnVuY3Rpb25zXG5jb25zdCBQUk9HUkVTU19LRVkgPSBcImNvbnRlbnRQcm9ncmVzc1wiXG5cbmV4cG9ydCBjb25zdCBzYXZlQ29udGVudFByb2dyZXNzID0gKGNvbnRlbnRJZDogc3RyaW5nLCBjdXJyZW50VGltZTogbnVtYmVyLCBkdXJhdGlvbjogbnVtYmVyLCBlcGlzb2RlSWQ/OiBzdHJpbmcpID0+IHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHJldHVyblxuXG4gIHRyeSB7XG4gICAgY29uc3QgcHJvZ3Jlc3NEYXRhID0gSlNPTi5wYXJzZShsb2NhbFN0b3JhZ2UuZ2V0SXRlbShQUk9HUkVTU19LRVkpIHx8IFwie31cIilcbiAgICBwcm9ncmVzc0RhdGFbY29udGVudElkICsgKGVwaXNvZGVJZCA/IGBfJHtlcGlzb2RlSWR9YCA6IFwiXCIpXSA9IHsgY3VycmVudFRpbWUsIGR1cmF0aW9uIH1cbiAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShQUk9HUkVTU19LRVksIEpTT04uc3RyaW5naWZ5KHByb2dyZXNzRGF0YSkpXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBzYXZlIGNvbnRlbnQgcHJvZ3Jlc3M6XCIsIGVycm9yKVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBnZXRDb250ZW50Q3VycmVudFRpbWUgPSAoY29udGVudElkOiBzdHJpbmcsIGVwaXNvZGVJZD86IHN0cmluZyk6IG51bWJlciB8IG51bGwgPT4ge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuIG51bGxcblxuICB0cnkge1xuICAgIGNvbnN0IHByb2dyZXNzRGF0YSA9IEpTT04ucGFyc2UobG9jYWxTdG9yYWdlLmdldEl0ZW0oUFJPR1JFU1NfS0VZKSB8fCBcInt9XCIpXG4gICAgY29uc3QgcHJvZ3Jlc3MgPSBwcm9ncmVzc0RhdGFbY29udGVudElkICsgKGVwaXNvZGVJZCA/IGBfJHtlcGlzb2RlSWR9YCA6IFwiXCIpXVxuICAgIHJldHVybiBwcm9ncmVzcyA/IHByb2dyZXNzLmN1cnJlbnRUaW1lIDogbnVsbFxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gZ2V0IGNvbnRlbnQgcHJvZ3Jlc3M6XCIsIGVycm9yKVxuICAgIHJldHVybiBudWxsXG4gIH1cbn1cblxuLy8gVGVzdCBDb25uZWN0aW9uXG5leHBvcnQgY29uc3QgdGVzdENvbm5lY3Rpb24gPSBhc3luYyAoKTogUHJvbWlzZTxib29sZWFuPiA9PiB7XG4gIHRyeSB7XG4gICAgLy8gQXR0ZW1wdCB0byBmZXRjaCBzZXJpZXMgKGEgYmFzaWMgQVBJIGNhbGwpXG4gICAgYXdhaXQgZ2V0QWxsU2VyaWVzKClcbiAgICByZXR1cm4gdHJ1ZVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJDb25uZWN0aW9uIHRlc3QgZmFpbGVkOlwiLCBlcnJvcilcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG4vLyBFcnJvciBNZXNzYWdlIEhlbHBlclxuZXhwb3J0IGNvbnN0IGdldEVycm9yTWVzc2FnZSA9IChlcnJvcjogYW55KTogc3RyaW5nID0+IHtcbiAgaWYgKGVycm9yIGluc3RhbmNlb2YgQXV0aGVudGljYXRpb25FcnJvcikge1xuICAgIHJldHVybiBcIkZhbGhhIG5hIGF1dGVudGljYcOnw6NvLiBWZXJpZmlxdWUgc3VhcyBjcmVkZW5jaWFpcy5cIlxuICB9IGVsc2UgaWYgKGVycm9yIGluc3RhbmNlb2YgTm90Rm91bmRFcnJvcikge1xuICAgIHJldHVybiBcIlJlY3Vyc28gbsOjbyBlbmNvbnRyYWRvLlwiXG4gIH0gZWxzZSBpZiAoZXJyb3IgaW5zdGFuY2VvZiBBcGlFcnJvcikge1xuICAgIHJldHVybiBgRXJybyBuYSBBUEk6ICR7ZXJyb3IubWVzc2FnZX1gXG4gIH0gZWxzZSBpZiAoZXJyb3IgaW5zdGFuY2VvZiBOZXR3b3JrRXJyb3IpIHtcbiAgICByZXR1cm4gXCJFcnJvIGRlIHJlZGUuIFZlcmlmaXF1ZSBzdWEgY29uZXjDo28gY29tIGEgaW50ZXJuZXQuXCJcbiAgfSBlbHNlIGlmIChlcnJvciBpbnN0YW5jZW9mIFR5cGVFcnJvciAmJiBlcnJvci5tZXNzYWdlLmluY2x1ZGVzKFwiRmFpbGVkIHRvIGZldGNoXCIpKSB7XG4gICAgcmV0dXJuIFwiRXJybyBhbyBjb25lY3RhciBhbyBzZXJ2aWRvci4gVmVyaWZpcXVlIGEgVVJMIGUgc3VhIGNvbmV4w6NvLlwiXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFwiT2NvcnJldSB1bSBlcnJvIGluZXNwZXJhZG8uXCJcbiAgfVxufVxuIl0sIm5hbWVzIjpbIkF1dGhlbnRpY2F0aW9uRXJyb3IiLCJFcnJvciIsImNvbnN0cnVjdG9yIiwibWVzc2FnZSIsIm5hbWUiLCJOb3RGb3VuZEVycm9yIiwiQXBpRXJyb3IiLCJzdGF0dXNDb2RlIiwiTmV0d29ya0Vycm9yIiwiZ2V0Q3JlZGVudGlhbHMiLCJzdG9yZWRDb25maWciLCJsb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwiY3JlZGVudGlhbHMiLCJKU09OIiwicGFyc2UiLCJmb3JjZUh0dHBzIiwiYXBpVXJsIiwidG9Mb3dlckNhc2UiLCJzdGFydHNXaXRoIiwicmVwbGFjZSIsImVycm9yIiwiY29uc29sZSIsImFwaVJlcXVlc3QiLCJlbmRwb2ludCIsInBhcmFtcyIsInJldHJpZXMiLCJ1c2VybmFtZSIsInBhc3N3b3JkIiwidXJsIiwiVVJMIiwid2luZG93IiwibG9jYXRpb24iLCJwcm90b2NvbCIsIndhcm4iLCJxdWVyeVBhcmFtcyIsIlVSTFNlYXJjaFBhcmFtcyIsImFjdGlvbiIsImZ1bGxVcmwiLCJ0b1N0cmluZyIsInJlc3BvbnNlIiwiZmV0Y2giLCJtZXRob2QiLCJtb2RlIiwiaGVhZGVycyIsInJlZmVycmVyUG9saWN5Iiwib2siLCJzdGF0dXMiLCJwcm9jZXNzIiwiZW52IiwiVVNFX1BST1hZIiwic3RhdHVzVGV4dCIsImRhdGEiLCJqc29uIiwiVHlwZUVycm9yIiwiZXJyb3JNZXNzYWdlIiwiaW5jbHVkZXMiLCJsb2ciLCJQcm9taXNlIiwicmVzb2x2ZSIsInNldFRpbWVvdXQiLCJnZXRTdHJlYW1VcmwiLCJzdHJlYW1JZCIsInN0cmVhbVR5cGUiLCJlcGlzb2RlSWQiLCJiYXNlVXJsIiwiQVBJX0VORFBPSU5UUyIsIkdFVF9BTExfU0VSSUVTIiwiR0VUX0FMTF9NT1ZJRVMiLCJHRVRfQUxMX0xJVkVfU1RSRUFNUyIsIkdFVF9TRVJJRVNfSU5GTyIsIkdFVF9NT1ZJRV9JTkZPIiwiU0VBUkNIIiwiZ2V0QWxsU2VyaWVzIiwiT2JqZWN0IiwiZW50cmllcyIsInNlcmllcyIsIm1hcCIsImlkIiwiZ2V0QWxsTW92aWVzIiwidm9kIiwibW92aWUiLCJnZXRBbGxMaXZlU3RyZWFtcyIsImxpdmUiLCJjaGFubmVsIiwiZ2V0U2VyaWVzSW5mbyIsInNlcmllc0lkIiwic2VyaWVzX2lkIiwiZ2V0TW92aWVJbmZvIiwidm9kSWQiLCJ2b2RfaWQiLCJzZWFyY2hDb250ZW50IiwicXVlcnkiLCJzZXJpZXNSZXN1bHRzIiwibWFwU2VyaWVzVG9Db250ZW50IiwibW92aWVSZXN1bHRzIiwibWFwTW92aWVUb0NvbnRlbnQiLCJjaGFubmVsUmVzdWx0cyIsIm1hcENoYW5uZWxUb0NvbnRlbnQiLCJ0aXRsZSIsImRlc2NyaXB0aW9uIiwicGxvdCIsInRodW1ibmFpbCIsImNvdmVyIiwidHlwZSIsImdlbnJlIiwieWVhciIsImR1cmF0aW9uIiwic3RyZWFtX2ljb24iLCJtYXBTZXJpZXNEZXRhaWxzVG9Db250ZW50Iiwic2VyaWVzRGV0YWlscyIsImluZm8iLCJlcGlzb2RlcyIsImVwaXNvZGUiLCJQUk9HUkVTU19LRVkiLCJzYXZlQ29udGVudFByb2dyZXNzIiwiY29udGVudElkIiwiY3VycmVudFRpbWUiLCJwcm9ncmVzc0RhdGEiLCJzZXRJdGVtIiwic3RyaW5naWZ5IiwiZ2V0Q29udGVudEN1cnJlbnRUaW1lIiwicHJvZ3Jlc3MiLCJ0ZXN0Q29ubmVjdGlvbiIsImdldEVycm9yTWVzc2FnZSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/api-service.ts\n"));

/***/ })

});