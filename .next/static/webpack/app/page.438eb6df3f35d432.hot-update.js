"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/api-service.ts":
/*!****************************!*\
  !*** ./lib/api-service.ts ***!
  \****************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ApiError: () => (/* binding */ ApiError),\n/* harmony export */   AuthenticationError: () => (/* binding */ AuthenticationError),\n/* harmony export */   NetworkError: () => (/* binding */ NetworkError),\n/* harmony export */   NotFoundError: () => (/* binding */ NotFoundError),\n/* harmony export */   getAllLiveStreams: () => (/* binding */ getAllLiveStreams),\n/* harmony export */   getAllMovies: () => (/* binding */ getAllMovies),\n/* harmony export */   getAllSeries: () => (/* binding */ getAllSeries),\n/* harmony export */   getContentCurrentTime: () => (/* binding */ getContentCurrentTime),\n/* harmony export */   getCredentials: () => (/* binding */ getCredentials),\n/* harmony export */   getErrorMessage: () => (/* binding */ getErrorMessage),\n/* harmony export */   getMovieInfo: () => (/* binding */ getMovieInfo),\n/* harmony export */   getSeriesInfo: () => (/* binding */ getSeriesInfo),\n/* harmony export */   getStreamUrl: () => (/* binding */ getStreamUrl),\n/* harmony export */   mapChannelToContent: () => (/* binding */ mapChannelToContent),\n/* harmony export */   mapMovieToContent: () => (/* binding */ mapMovieToContent),\n/* harmony export */   mapSeriesDetailsToContent: () => (/* binding */ mapSeriesDetailsToContent),\n/* harmony export */   mapSeriesToContent: () => (/* binding */ mapSeriesToContent),\n/* harmony export */   saveContentProgress: () => (/* binding */ saveContentProgress),\n/* harmony export */   searchContent: () => (/* binding */ searchContent),\n/* harmony export */   testConnection: () => (/* binding */ testConnection)\n/* harmony export */ });\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n// Update the ApiCredentials interface to include forceHttps\n// Custom error classes\nclass AuthenticationError extends Error {\n    constructor(message = \"Authentication failed\"){\n        super(message);\n        this.name = \"AuthenticationError\";\n    }\n}\nclass NotFoundError extends Error {\n    constructor(message = \"Resource not found\"){\n        super(message);\n        this.name = \"NotFoundError\";\n    }\n}\nclass ApiError extends Error {\n    constructor(message = \"API error\", statusCode){\n        super(message);\n        this.name = \"ApiError\";\n        this.statusCode = statusCode;\n    }\n}\nclass NetworkError extends Error {\n    constructor(message = \"Network error\"){\n        super(message);\n        this.name = \"NetworkError\";\n    }\n}\n// Update the getCredentials function to handle the forceHttps option\nconst getCredentials = ()=>{\n    if (false) {}\n    const storedConfig = localStorage.getItem(\"streamConfig\");\n    if (!storedConfig) return null;\n    try {\n        const credentials = JSON.parse(storedConfig);\n        // If forceHttps is enabled, ensure the URL uses HTTPS\n        if (credentials.forceHttps && credentials.apiUrl.toLowerCase().startsWith(\"http:\")) {\n            credentials.apiUrl = credentials.apiUrl.replace(/^http:/i, \"https:\");\n        }\n        return credentials;\n    } catch (error) {\n        console.error(\"Failed to parse stored credentials:\", error);\n        return null;\n    }\n};\n// Update the apiRequest function to better handle mixed content errors\nasync function apiRequest(endpoint) {\n    let params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, retries = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 2;\n    const credentials = getCredentials();\n    if (!credentials) {\n        throw new AuthenticationError(\"Credenciais não encontradas. Configure o aplicativo primeiro.\");\n    }\n    const { apiUrl, username, password } = credentials;\n    // Build URL with credentials and params\n    let url;\n    try {\n        url = new URL(apiUrl);\n    } catch (error) {\n        throw new Error(\"URL inv\\xe1lida: \".concat(apiUrl, \". Verifique a configura\\xe7\\xe3o.\"));\n    }\n    // Check for potential mixed content issues\n    if ( true && window.location.protocol === \"https:\" && url.protocol === \"http:\") {\n        console.warn(\"Potential mixed content issue: trying to load HTTP content in an HTTPS page\");\n    }\n    // Add authentication params and action\n    const queryParams = new URLSearchParams({\n        username,\n        password,\n        action: endpoint,\n        ...params\n    });\n    let fullUrl = \"\".concat(url.toString(), \"?\").concat(queryParams.toString());\n    // Use a configurable proxy to bypass CORS if necessary\n    const proxyUrl = process.env.CORS_PROXY || \"https://cors-anywhere.herokuapp.com/\";\n    if (process.env.USE_PROXY === \"true\") {\n        fullUrl = \"\".concat(proxyUrl).concat(fullUrl);\n    }\n    try {\n        const response = await fetch(fullUrl, {\n            // Add a timeout to the request\n            signal: AbortSignal.timeout(15000),\n            headers: {\n                \"Accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7\",\n                \"Accept-Encoding\": \"gzip, deflate\",\n                \"Accept-Language\": \"pt-BR,pt;q=0.9,en-US;q=0.8,en;q=0.7\",\n                \"Cache-Control\": \"max-age=0\",\n                \"Connection\": \"keep-alive\",\n                \"DNT\": \"1\",\n                \"Host\": \"gvf15.com\",\n                \"Upgrade-Insecure-Requests\": \"1\",\n                \"User-Agent\": \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/135.0.0.0 Safari/537.36\"\n            }\n        });\n        // Handle different HTTP status codes\n        if (!response.ok) {\n            if (response.status === 401 || response.status === 403) {\n                throw new AuthenticationError();\n            } else if (response.status === 404) {\n                throw new NotFoundError();\n            } else if (response.status === 500 && process.env.USE_PROXY !== \"true\") {\n                console.warn(\"Erro 500 detectado. Tentando novamente com proxy habilitado.\");\n                process.env.USE_PROXY = \"true\";\n                return apiRequest(endpoint, params, retries);\n            } else {\n                throw new ApiError(\"Erro na API: \".concat(response.statusText), response.status);\n            }\n        }\n        // Parse JSON response\n        try {\n            const data = await response.json();\n            // Some APIs return error information in the response body\n            if (data && data.error) {\n                throw new ApiError(\"Erro na API: \".concat(data.error));\n            }\n            return data;\n        } catch (error) {\n            throw new ApiError(\"Erro ao processar resposta da API. Formato inválido.\");\n        }\n    } catch (error) {\n        // Check specifically for mixed content errors\n        if (error instanceof TypeError) {\n            const errorMessage = error.message.toLowerCase();\n            if (errorMessage.includes(\"mixed content\") || errorMessage.includes(\"blocked\") && errorMessage.includes(\"insecure\")) {\n                throw new NetworkError(\"Erro de conteúdo misto: seu navegador bloqueou a requisição HTTP em um site HTTPS. \" + \"Tente ativar 'Forçar HTTPS' nas configurações ou use um servidor com HTTPS.\");\n            }\n            // Handle network errors and implement retry logic\n            if (errorMessage.includes(\"fetch\")) {\n                // Network error\n                if (retries > 0) {\n                    console.log(\"Retry attempt (\".concat(retries, \" remaining) for \").concat(fullUrl));\n                    // Exponential backoff: wait longer between retries\n                    await new Promise((resolve)=>setTimeout(resolve, (3 - retries) * 1000));\n                    return apiRequest(endpoint, params, retries - 1);\n                }\n                throw new NetworkError();\n            }\n        }\n        // Re-throw other errors\n        throw error;\n    }\n}\n// Update the getStreamUrl function to handle HTTPS\nconst getStreamUrl = (streamId, streamType, episodeId)=>{\n    const credentials = getCredentials();\n    if (!credentials) {\n        throw new AuthenticationError(\"Credenciais não encontradas. Configure o aplicativo primeiro.\");\n    }\n    const { apiUrl, username, password, forceHttps } = credentials;\n    let baseUrl = apiUrl.replace(\"player_api.php\", \"\");\n    // If forceHttps is enabled, ensure the URL uses HTTPS\n    if (forceHttps && baseUrl.toLowerCase().startsWith(\"http:\")) {\n        baseUrl = baseUrl.replace(/^http:/i, \"https:\");\n    }\n    if (streamType === \"live\") {\n        return \"\".concat(baseUrl, \"live/\").concat(username, \"/\").concat(password, \"/\").concat(streamId, \".ts\");\n    } else if (streamType === \"movie\") {\n        return \"\".concat(baseUrl, \"movie/\").concat(username, \"/\").concat(password, \"/\").concat(streamId, \".mp4\");\n    } else if (streamType === \"series\" && episodeId) {\n        return \"\".concat(baseUrl, \"series/\").concat(username, \"/\").concat(password, \"/\").concat(streamId, \"/\").concat(episodeId, \".mp4\");\n    }\n    throw new Error(\"Tipo de stream inválido ou ID de episódio ausente para séries\");\n};\n// API Endpoints and Data Mapping\nconst API_ENDPOINTS = {\n    GET_ALL_SERIES: \"get_series\",\n    GET_ALL_MOVIES: \"get_vod\",\n    GET_ALL_LIVE_STREAMS: \"get_live_streams\",\n    GET_SERIES_INFO: \"get_series_info\",\n    GET_MOVIE_INFO: \"get_vod_info\",\n    SEARCH: \"search\"\n};\n// API Calls\nconst getAllSeries = async ()=>{\n    const response = await apiRequest(\"get_series\");\n    return Object.entries(response.series || {}).map((param)=>{\n        let [id, series] = param;\n        return {\n            id,\n            ...series\n        };\n    });\n};\nconst getAllMovies = async ()=>{\n    const response = await apiRequest(\"get_vod\");\n    return Object.entries(response.vod || {}).map((param)=>{\n        let [id, movie] = param;\n        return {\n            id,\n            ...movie\n        };\n    });\n};\nconst getAllLiveStreams = async ()=>{\n    const response = await apiRequest(\"get_live_streams\");\n    return Object.entries(response.live || {}).map((param)=>{\n        let [id, channel] = param;\n        return {\n            id,\n            ...channel\n        };\n    });\n};\nconst getSeriesInfo = async (seriesId)=>{\n    const response = await apiRequest(API_ENDPOINTS.GET_SERIES_INFO, {\n        series_id: seriesId\n    });\n    return response;\n};\nconst getMovieInfo = async (vodId)=>{\n    const response = await apiRequest(API_ENDPOINTS.GET_MOVIE_INFO, {\n        vod_id: vodId\n    });\n    return response;\n};\nconst searchContent = async (query)=>{\n    try {\n        const response = await apiRequest(API_ENDPOINTS.SEARCH, {\n            query: query\n        });\n        if (!response || !response.data) {\n            return [];\n        }\n        const seriesResults = Object.entries(response.data.series || {}).map((param)=>{\n            let [id, series] = param;\n            return mapSeriesToContent({\n                id,\n                ...series\n            });\n        });\n        const movieResults = Object.entries(response.data.vod || {}).map((param)=>{\n            let [id, movie] = param;\n            return mapMovieToContent({\n                id,\n                ...movie\n            });\n        });\n        const channelResults = Object.entries(response.data.live || {}).map((param)=>{\n            let [id, channel] = param;\n            return mapChannelToContent({\n                id,\n                ...channel\n            });\n        });\n        return [\n            ...seriesResults,\n            ...movieResults,\n            ...channelResults\n        ];\n    } catch (error) {\n        console.error(\"Search failed:\", error);\n        return [];\n    }\n};\n// Data Mapping Functions\nconst mapSeriesToContent = (series)=>({\n        id: series.id,\n        title: series.name,\n        description: series.plot,\n        thumbnail: series.cover,\n        type: \"series\",\n        genre: series.genre,\n        year: series.year\n    });\nconst mapMovieToContent = (movie)=>({\n        id: movie.id,\n        title: movie.name,\n        description: movie.plot,\n        thumbnail: movie.cover,\n        type: \"movie\",\n        genre: movie.genre,\n        year: movie.year,\n        duration: movie.duration\n    });\nconst mapChannelToContent = (channel)=>({\n        id: channel.id,\n        title: channel.name,\n        description: \"\",\n        thumbnail: channel.stream_icon,\n        type: \"channel\"\n    });\nconst mapSeriesDetailsToContent = (seriesDetails)=>{\n    const series = seriesDetails.info;\n    const episodes = Object.entries(seriesDetails.episodes || {}).map((param)=>{\n        let [episodeId, episode] = param;\n        return {\n            id: episodeId,\n            title: episode.title,\n            description: episode.plot,\n            duration: episode.duration\n        };\n    });\n    return {\n        id: series.id,\n        title: series.name,\n        description: series.plot,\n        thumbnail: series.cover,\n        type: \"series\",\n        genre: series.genre,\n        year: series.year,\n        episodes: episodes\n    };\n};\n// Local Storage Functions\nconst PROGRESS_KEY = \"contentProgress\";\nconst saveContentProgress = (contentId, currentTime, duration, episodeId)=>{\n    if (false) {}\n    try {\n        const progressData = JSON.parse(localStorage.getItem(PROGRESS_KEY) || \"{}\");\n        progressData[contentId + (episodeId ? \"_\".concat(episodeId) : \"\")] = {\n            currentTime,\n            duration\n        };\n        localStorage.setItem(PROGRESS_KEY, JSON.stringify(progressData));\n    } catch (error) {\n        console.error(\"Failed to save content progress:\", error);\n    }\n};\nconst getContentCurrentTime = (contentId, episodeId)=>{\n    if (false) {}\n    try {\n        const progressData = JSON.parse(localStorage.getItem(PROGRESS_KEY) || \"{}\");\n        const progress = progressData[contentId + (episodeId ? \"_\".concat(episodeId) : \"\")];\n        return progress ? progress.currentTime : null;\n    } catch (error) {\n        console.error(\"Failed to get content progress:\", error);\n        return null;\n    }\n};\n// Test Connection\nconst testConnection = async ()=>{\n    try {\n        // Attempt to fetch series (a basic API call)\n        await getAllSeries();\n        return true;\n    } catch (error) {\n        console.error(\"Connection test failed:\", error);\n        return false;\n    }\n};\n// Error Message Helper\nconst getErrorMessage = (error)=>{\n    if (error instanceof AuthenticationError) {\n        return \"Falha na autenticação. Verifique suas credenciais.\";\n    } else if (error instanceof NotFoundError) {\n        return \"Recurso não encontrado.\";\n    } else if (error instanceof ApiError) {\n        return \"Erro na API: \".concat(error.message);\n    } else if (error instanceof NetworkError) {\n        return \"Erro de rede. Verifique sua conexão com a internet.\";\n    } else if (error instanceof TypeError && error.message.includes(\"Failed to fetch\")) {\n        return \"Erro ao conectar ao servidor. Verifique a URL e sua conexão.\";\n    } else {\n        return \"Ocorreu um erro inesperado.\";\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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V0EsU0FBU0wsV0FBVyxHQUFHO0lBQzNDLEVBQUUsT0FBT2xHLE9BQU87UUFDZEMsUUFBUUQsS0FBSyxDQUFDLG1DQUFtQ0E7UUFDakQsT0FBTztJQUNUO0FBQ0YsRUFBQztBQUVELGtCQUFrQjtBQUNYLE1BQU13RyxpQkFBaUI7SUFDNUIsSUFBSTtRQUNGLDZDQUE2QztRQUM3QyxNQUFNbEQ7UUFDTixPQUFPO0lBQ1QsRUFBRSxPQUFPdEQsT0FBTztRQUNkQyxRQUFRRCxLQUFLLENBQUMsMkJBQTJCQTtRQUN6QyxPQUFPO0lBQ1Q7QUFDRixFQUFDO0FBRUQsdUJBQXVCO0FBQ2hCLE1BQU15RyxrQkFBa0IsQ0FBQ3pHO0lBQzlCLElBQUlBLGlCQUFpQnJCLHFCQUFxQjtRQUN4QyxPQUFPO0lBQ1QsT0FBTyxJQUFJcUIsaUJBQWlCaEIsZUFBZTtRQUN6QyxPQUFPO0lBQ1QsT0FBTyxJQUFJZ0IsaUJBQWlCZixVQUFVO1FBQ3BDLE9BQU8sZ0JBQThCLE9BQWRlLE1BQU1sQixPQUFPO0lBQ3RDLE9BQU8sSUFBSWtCLGlCQUFpQmIsY0FBYztRQUN4QyxPQUFPO0lBQ1QsT0FBTyxJQUFJYSxpQkFBaUJtQyxhQUFhbkMsTUFBTWxCLE9BQU8sQ0FBQ3VELFFBQVEsQ0FBQyxvQkFBb0I7UUFDbEYsT0FBTztJQUNULE9BQU87UUFDTCxPQUFPO0lBQ1Q7QUFDRixFQUFDIiwic291cmNlcyI6WyIvVXNlcnMvaGVpdG9yLmNhbmRpZG8vRG9jdW1lbnRzL2lwdHYvaXB0di1hcHAvbGliL2FwaS1zZXJ2aWNlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFVwZGF0ZSB0aGUgQXBpQ3JlZGVudGlhbHMgaW50ZXJmYWNlIHRvIGluY2x1ZGUgZm9yY2VIdHRwc1xuZXhwb3J0IGludGVyZmFjZSBBcGlDcmVkZW50aWFscyB7XG4gIGFwaVVybDogc3RyaW5nXG4gIHVzZXJuYW1lOiBzdHJpbmdcbiAgcGFzc3dvcmQ6IHN0cmluZ1xuICBmb3JjZUh0dHBzPzogYm9vbGVhblxufVxuXG4vLyBDdXN0b20gZXJyb3IgY2xhc3Nlc1xuZXhwb3J0IGNsYXNzIEF1dGhlbnRpY2F0aW9uRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UgPSBcIkF1dGhlbnRpY2F0aW9uIGZhaWxlZFwiKSB7XG4gICAgc3VwZXIobWVzc2FnZSlcbiAgICB0aGlzLm5hbWUgPSBcIkF1dGhlbnRpY2F0aW9uRXJyb3JcIlxuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBOb3RGb3VuZEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlID0gXCJSZXNvdXJjZSBub3QgZm91bmRcIikge1xuICAgIHN1cGVyKG1lc3NhZ2UpXG4gICAgdGhpcy5uYW1lID0gXCJOb3RGb3VuZEVycm9yXCJcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgQXBpRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIHB1YmxpYyBzdGF0dXNDb2RlOiBudW1iZXIgfCB1bmRlZmluZWRcblxuICBjb25zdHJ1Y3RvcihtZXNzYWdlID0gXCJBUEkgZXJyb3JcIiwgc3RhdHVzQ29kZT86IG51bWJlcikge1xuICAgIHN1cGVyKG1lc3NhZ2UpXG4gICAgdGhpcy5uYW1lID0gXCJBcGlFcnJvclwiXG4gICAgdGhpcy5zdGF0dXNDb2RlID0gc3RhdHVzQ29kZVxuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBOZXR3b3JrRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UgPSBcIk5ldHdvcmsgZXJyb3JcIikge1xuICAgIHN1cGVyKG1lc3NhZ2UpXG4gICAgdGhpcy5uYW1lID0gXCJOZXR3b3JrRXJyb3JcIlxuICB9XG59XG5cbi8vIFVwZGF0ZSB0aGUgZ2V0Q3JlZGVudGlhbHMgZnVuY3Rpb24gdG8gaGFuZGxlIHRoZSBmb3JjZUh0dHBzIG9wdGlvblxuZXhwb3J0IGNvbnN0IGdldENyZWRlbnRpYWxzID0gKCk6IEFwaUNyZWRlbnRpYWxzIHwgbnVsbCA9PiB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSByZXR1cm4gbnVsbFxuXG4gIGNvbnN0IHN0b3JlZENvbmZpZyA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKFwic3RyZWFtQ29uZmlnXCIpXG4gIGlmICghc3RvcmVkQ29uZmlnKSByZXR1cm4gbnVsbFxuXG4gIHRyeSB7XG4gICAgY29uc3QgY3JlZGVudGlhbHMgPSBKU09OLnBhcnNlKHN0b3JlZENvbmZpZykgYXMgQXBpQ3JlZGVudGlhbHNcblxuICAgIC8vIElmIGZvcmNlSHR0cHMgaXMgZW5hYmxlZCwgZW5zdXJlIHRoZSBVUkwgdXNlcyBIVFRQU1xuICAgIGlmIChjcmVkZW50aWFscy5mb3JjZUh0dHBzICYmIGNyZWRlbnRpYWxzLmFwaVVybC50b0xvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgoXCJodHRwOlwiKSkge1xuICAgICAgY3JlZGVudGlhbHMuYXBpVXJsID0gY3JlZGVudGlhbHMuYXBpVXJsLnJlcGxhY2UoL15odHRwOi9pLCBcImh0dHBzOlwiKVxuICAgIH1cblxuICAgIHJldHVybiBjcmVkZW50aWFsc1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gcGFyc2Ugc3RvcmVkIGNyZWRlbnRpYWxzOlwiLCBlcnJvcilcbiAgICByZXR1cm4gbnVsbFxuICB9XG59XG5cbi8vIFVwZGF0ZSB0aGUgYXBpUmVxdWVzdCBmdW5jdGlvbiB0byBiZXR0ZXIgaGFuZGxlIG1peGVkIGNvbnRlbnQgZXJyb3JzXG5hc3luYyBmdW5jdGlvbiBhcGlSZXF1ZXN0PFQ+KGVuZHBvaW50OiBzdHJpbmcsIHBhcmFtczogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IHt9LCByZXRyaWVzID0gMik6IFByb21pc2U8VD4ge1xuICBjb25zdCBjcmVkZW50aWFscyA9IGdldENyZWRlbnRpYWxzKClcbiAgaWYgKCFjcmVkZW50aWFscykge1xuICAgIHRocm93IG5ldyBBdXRoZW50aWNhdGlvbkVycm9yKFwiQ3JlZGVuY2lhaXMgbsOjbyBlbmNvbnRyYWRhcy4gQ29uZmlndXJlIG8gYXBsaWNhdGl2byBwcmltZWlyby5cIilcbiAgfVxuXG4gIGNvbnN0IHsgYXBpVXJsLCB1c2VybmFtZSwgcGFzc3dvcmQgfSA9IGNyZWRlbnRpYWxzXG5cbiAgLy8gQnVpbGQgVVJMIHdpdGggY3JlZGVudGlhbHMgYW5kIHBhcmFtc1xuICBsZXQgdXJsOiBVUkxcbiAgdHJ5IHtcbiAgICB1cmwgPSBuZXcgVVJMKGFwaVVybClcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVSTCBpbnbDoWxpZGE6ICR7YXBpVXJsfS4gVmVyaWZpcXVlIGEgY29uZmlndXJhw6fDo28uYClcbiAgfVxuXG4gIC8vIENoZWNrIGZvciBwb3RlbnRpYWwgbWl4ZWQgY29udGVudCBpc3N1ZXNcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93LmxvY2F0aW9uLnByb3RvY29sID09PSBcImh0dHBzOlwiICYmIHVybC5wcm90b2NvbCA9PT0gXCJodHRwOlwiKSB7XG4gICAgY29uc29sZS53YXJuKFwiUG90ZW50aWFsIG1peGVkIGNvbnRlbnQgaXNzdWU6IHRyeWluZyB0byBsb2FkIEhUVFAgY29udGVudCBpbiBhbiBIVFRQUyBwYWdlXCIpXG4gIH1cblxuICAvLyBBZGQgYXV0aGVudGljYXRpb24gcGFyYW1zIGFuZCBhY3Rpb25cbiAgY29uc3QgcXVlcnlQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHtcbiAgICB1c2VybmFtZSxcbiAgICBwYXNzd29yZCxcbiAgICBhY3Rpb246IGVuZHBvaW50LCAvLyBBZGQgdGhlIGFjdGlvbiBwYXJhbWV0ZXIgaGVyZVxuICAgIC4uLnBhcmFtcyxcbiAgfSlcblxuICBsZXQgZnVsbFVybCA9IGAke3VybC50b1N0cmluZygpfT8ke3F1ZXJ5UGFyYW1zLnRvU3RyaW5nKCl9YFxuXG4gIC8vIFVzZSBhIGNvbmZpZ3VyYWJsZSBwcm94eSB0byBieXBhc3MgQ09SUyBpZiBuZWNlc3NhcnlcbiAgY29uc3QgcHJveHlVcmwgPSBwcm9jZXNzLmVudi5DT1JTX1BST1hZIHx8IFwiaHR0cHM6Ly9jb3JzLWFueXdoZXJlLmhlcm9rdWFwcC5jb20vXCJcbiAgaWYgKHByb2Nlc3MuZW52LlVTRV9QUk9YWSA9PT0gXCJ0cnVlXCIpIHtcbiAgICBmdWxsVXJsID0gYCR7cHJveHlVcmx9JHtmdWxsVXJsfWBcbiAgfVxuXG4gIHRyeSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChmdWxsVXJsLCB7XG4gICAgICAvLyBBZGQgYSB0aW1lb3V0IHRvIHRoZSByZXF1ZXN0XG4gICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQoMTUwMDApLCAvLyAxNSBzZWNvbmRzIHRpbWVvdXRcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgXCJBY2NlcHRcIjogXCJ0ZXh0L2h0bWwsYXBwbGljYXRpb24veGh0bWwreG1sLGFwcGxpY2F0aW9uL3htbDtxPTAuOSxpbWFnZS9hdmlmLGltYWdlL3dlYnAsaW1hZ2UvYXBuZywqLyo7cT0wLjgsYXBwbGljYXRpb24vc2lnbmVkLWV4Y2hhbmdlO3Y9YjM7cT0wLjdcIixcbiAgICAgICAgXCJBY2NlcHQtRW5jb2RpbmdcIjogXCJnemlwLCBkZWZsYXRlXCIsXG4gICAgICAgIFwiQWNjZXB0LUxhbmd1YWdlXCI6IFwicHQtQlIscHQ7cT0wLjksZW4tVVM7cT0wLjgsZW47cT0wLjdcIixcbiAgICAgICAgXCJDYWNoZS1Db250cm9sXCI6IFwibWF4LWFnZT0wXCIsXG4gICAgICAgIFwiQ29ubmVjdGlvblwiOiBcImtlZXAtYWxpdmVcIixcbiAgICAgICAgXCJETlRcIjogXCIxXCIsXG4gICAgICAgIFwiSG9zdFwiOiBcImd2ZjE1LmNvbVwiLFxuICAgICAgICBcIlVwZ3JhZGUtSW5zZWN1cmUtUmVxdWVzdHNcIjogXCIxXCIsXG4gICAgICAgIFwiVXNlci1BZ2VudFwiOiBcIk1vemlsbGEvNS4wIChNYWNpbnRvc2g7IEludGVsIE1hYyBPUyBYIDEwXzE1XzcpIEFwcGxlV2ViS2l0LzUzNy4zNiAoS0hUTUwsIGxpa2UgR2Vja28pIENocm9tZS8xMzUuMC4wLjAgU2FmYXJpLzUzNy4zNlwiLFxuICAgICAgfSxcbiAgICB9KVxuXG4gICAgLy8gSGFuZGxlIGRpZmZlcmVudCBIVFRQIHN0YXR1cyBjb2Rlc1xuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQwMSB8fCByZXNwb25zZS5zdGF0dXMgPT09IDQwMykge1xuICAgICAgICB0aHJvdyBuZXcgQXV0aGVudGljYXRpb25FcnJvcigpXG4gICAgICB9IGVsc2UgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDA0KSB7XG4gICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEVycm9yKClcbiAgICAgIH0gZWxzZSBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA1MDAgJiYgcHJvY2Vzcy5lbnYuVVNFX1BST1hZICE9PSBcInRydWVcIikge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJFcnJvIDUwMCBkZXRlY3RhZG8uIFRlbnRhbmRvIG5vdmFtZW50ZSBjb20gcHJveHkgaGFiaWxpdGFkby5cIilcbiAgICAgICAgcHJvY2Vzcy5lbnYuVVNFX1BST1hZID0gXCJ0cnVlXCJcbiAgICAgICAgcmV0dXJuIGFwaVJlcXVlc3Q8VD4oZW5kcG9pbnQsIHBhcmFtcywgcmV0cmllcylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBBcGlFcnJvcihgRXJybyBuYSBBUEk6ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gLCByZXNwb25zZS5zdGF0dXMpXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUGFyc2UgSlNPTiByZXNwb25zZVxuICAgIHRyeSB7XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpXG5cbiAgICAgIC8vIFNvbWUgQVBJcyByZXR1cm4gZXJyb3IgaW5mb3JtYXRpb24gaW4gdGhlIHJlc3BvbnNlIGJvZHlcbiAgICAgIGlmIChkYXRhICYmIGRhdGEuZXJyb3IpIHtcbiAgICAgICAgdGhyb3cgbmV3IEFwaUVycm9yKGBFcnJvIG5hIEFQSTogJHtkYXRhLmVycm9yfWApXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkYXRhIGFzIFRcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEFwaUVycm9yKFwiRXJybyBhbyBwcm9jZXNzYXIgcmVzcG9zdGEgZGEgQVBJLiBGb3JtYXRvIGludsOhbGlkby5cIilcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgLy8gQ2hlY2sgc3BlY2lmaWNhbGx5IGZvciBtaXhlZCBjb250ZW50IGVycm9yc1xuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIFR5cGVFcnJvcikge1xuICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gZXJyb3IubWVzc2FnZS50b0xvd2VyQ2FzZSgpXG5cbiAgICAgIGlmIChcbiAgICAgICAgZXJyb3JNZXNzYWdlLmluY2x1ZGVzKFwibWl4ZWQgY29udGVudFwiKSB8fFxuICAgICAgICAoZXJyb3JNZXNzYWdlLmluY2x1ZGVzKFwiYmxvY2tlZFwiKSAmJiBlcnJvck1lc3NhZ2UuaW5jbHVkZXMoXCJpbnNlY3VyZVwiKSlcbiAgICAgICkge1xuICAgICAgICB0aHJvdyBuZXcgTmV0d29ya0Vycm9yKFxuICAgICAgICAgIFwiRXJybyBkZSBjb250ZcO6ZG8gbWlzdG86IHNldSBuYXZlZ2Fkb3IgYmxvcXVlb3UgYSByZXF1aXNpw6fDo28gSFRUUCBlbSB1bSBzaXRlIEhUVFBTLiBcIiArXG4gICAgICAgICAgICBcIlRlbnRlIGF0aXZhciAnRm9yw6dhciBIVFRQUycgbmFzIGNvbmZpZ3VyYcOnw7VlcyBvdSB1c2UgdW0gc2Vydmlkb3IgY29tIEhUVFBTLlwiLFxuICAgICAgICApXG4gICAgICB9XG5cbiAgICAgIC8vIEhhbmRsZSBuZXR3b3JrIGVycm9ycyBhbmQgaW1wbGVtZW50IHJldHJ5IGxvZ2ljXG4gICAgICBpZiAoZXJyb3JNZXNzYWdlLmluY2x1ZGVzKFwiZmV0Y2hcIikpIHtcbiAgICAgICAgLy8gTmV0d29yayBlcnJvclxuICAgICAgICBpZiAocmV0cmllcyA+IDApIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhgUmV0cnkgYXR0ZW1wdCAoJHtyZXRyaWVzfSByZW1haW5pbmcpIGZvciAke2Z1bGxVcmx9YClcbiAgICAgICAgICAvLyBFeHBvbmVudGlhbCBiYWNrb2ZmOiB3YWl0IGxvbmdlciBiZXR3ZWVuIHJldHJpZXNcbiAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCAoMyAtIHJldHJpZXMpICogMTAwMCkpXG4gICAgICAgICAgcmV0dXJuIGFwaVJlcXVlc3Q8VD4oZW5kcG9pbnQsIHBhcmFtcywgcmV0cmllcyAtIDEpXG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IE5ldHdvcmtFcnJvcigpXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmUtdGhyb3cgb3RoZXIgZXJyb3JzXG4gICAgdGhyb3cgZXJyb3JcbiAgfVxufVxuXG4vLyBVcGRhdGUgdGhlIGdldFN0cmVhbVVybCBmdW5jdGlvbiB0byBoYW5kbGUgSFRUUFNcbmV4cG9ydCBjb25zdCBnZXRTdHJlYW1VcmwgPSAoc3RyZWFtSWQ6IHN0cmluZywgc3RyZWFtVHlwZTogXCJsaXZlXCIgfCBcIm1vdmllXCIgfCBcInNlcmllc1wiLCBlcGlzb2RlSWQ/OiBzdHJpbmcpOiBzdHJpbmcgPT4ge1xuICBjb25zdCBjcmVkZW50aWFscyA9IGdldENyZWRlbnRpYWxzKClcbiAgaWYgKCFjcmVkZW50aWFscykge1xuICAgIHRocm93IG5ldyBBdXRoZW50aWNhdGlvbkVycm9yKFwiQ3JlZGVuY2lhaXMgbsOjbyBlbmNvbnRyYWRhcy4gQ29uZmlndXJlIG8gYXBsaWNhdGl2byBwcmltZWlyby5cIilcbiAgfVxuXG4gIGNvbnN0IHsgYXBpVXJsLCB1c2VybmFtZSwgcGFzc3dvcmQsIGZvcmNlSHR0cHMgfSA9IGNyZWRlbnRpYWxzXG4gIGxldCBiYXNlVXJsID0gYXBpVXJsLnJlcGxhY2UoXCJwbGF5ZXJfYXBpLnBocFwiLCBcIlwiKVxuXG4gIC8vIElmIGZvcmNlSHR0cHMgaXMgZW5hYmxlZCwgZW5zdXJlIHRoZSBVUkwgdXNlcyBIVFRQU1xuICBpZiAoZm9yY2VIdHRwcyAmJiBiYXNlVXJsLnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aChcImh0dHA6XCIpKSB7XG4gICAgYmFzZVVybCA9IGJhc2VVcmwucmVwbGFjZSgvXmh0dHA6L2ksIFwiaHR0cHM6XCIpXG4gIH1cblxuICBpZiAoc3RyZWFtVHlwZSA9PT0gXCJsaXZlXCIpIHtcbiAgICByZXR1cm4gYCR7YmFzZVVybH1saXZlLyR7dXNlcm5hbWV9LyR7cGFzc3dvcmR9LyR7c3RyZWFtSWR9LnRzYFxuICB9IGVsc2UgaWYgKHN0cmVhbVR5cGUgPT09IFwibW92aWVcIikge1xuICAgIHJldHVybiBgJHtiYXNlVXJsfW1vdmllLyR7dXNlcm5hbWV9LyR7cGFzc3dvcmR9LyR7c3RyZWFtSWR9Lm1wNGBcbiAgfSBlbHNlIGlmIChzdHJlYW1UeXBlID09PSBcInNlcmllc1wiICYmIGVwaXNvZGVJZCkge1xuICAgIHJldHVybiBgJHtiYXNlVXJsfXNlcmllcy8ke3VzZXJuYW1lfS8ke3Bhc3N3b3JkfS8ke3N0cmVhbUlkfS8ke2VwaXNvZGVJZH0ubXA0YFxuICB9XG5cbiAgdGhyb3cgbmV3IEVycm9yKFwiVGlwbyBkZSBzdHJlYW0gaW52w6FsaWRvIG91IElEIGRlIGVwaXPDs2RpbyBhdXNlbnRlIHBhcmEgc8Opcmllc1wiKVxufVxuXG4vLyBBUEkgRW5kcG9pbnRzIGFuZCBEYXRhIE1hcHBpbmdcbmNvbnN0IEFQSV9FTkRQT0lOVFMgPSB7XG4gIEdFVF9BTExfU0VSSUVTOiBcImdldF9zZXJpZXNcIixcbiAgR0VUX0FMTF9NT1ZJRVM6IFwiZ2V0X3ZvZFwiLFxuICBHRVRfQUxMX0xJVkVfU1RSRUFNUzogXCJnZXRfbGl2ZV9zdHJlYW1zXCIsXG4gIEdFVF9TRVJJRVNfSU5GTzogXCJnZXRfc2VyaWVzX2luZm9cIixcbiAgR0VUX01PVklFX0lORk86IFwiZ2V0X3ZvZF9pbmZvXCIsXG4gIFNFQVJDSDogXCJzZWFyY2hcIixcbn1cblxuaW50ZXJmYWNlIEFwaVJlc3BvbnNlPFQ+IHtcbiAgc3RhdHVzOiBib29sZWFuXG4gIGRhdGE6IFRcbiAgZXJyb3I/OiBzdHJpbmdcbn1cblxuLy8gRGF0YSBUeXBlc1xuZXhwb3J0IGludGVyZmFjZSBDb250ZW50SXRlbSB7XG4gIGlkOiBzdHJpbmdcbiAgdGl0bGU6IHN0cmluZ1xuICBkZXNjcmlwdGlvbjogc3RyaW5nXG4gIHRodW1ibmFpbDogc3RyaW5nXG4gIGJhY2tkcm9wPzogc3RyaW5nXG4gIHR5cGU6IFwic2VyaWVzXCIgfCBcIm1vdmllXCIgfCBcImNoYW5uZWxcIlxuICBnZW5yZT86IHN0cmluZ1xuICB5ZWFyPzogc3RyaW5nXG4gIGR1cmF0aW9uPzogc3RyaW5nXG4gIHByb2dyZXNzPzogbnVtYmVyXG4gIGVwaXNvZGVzPzogRXBpc29kZVtdXG4gIGluZm8/OiBhbnlcbn1cblxuZXhwb3J0IGludGVyZmFjZSBFcGlzb2RlIHtcbiAgaWQ6IHN0cmluZ1xuICB0aXRsZTogc3RyaW5nXG4gIGRlc2NyaXB0aW9uOiBzdHJpbmdcbiAgdGh1bWJuYWlsPzogc3RyaW5nXG4gIGR1cmF0aW9uPzogc3RyaW5nXG4gIHByb2dyZXNzPzogbnVtYmVyXG59XG5cbmludGVyZmFjZSBTZXJpZXNSZXNwb25zZSB7XG4gIHNlcmllczoge1xuICAgIFtzZXJpZXNJZDogc3RyaW5nXToge1xuICAgICAgbmFtZTogc3RyaW5nXG4gICAgICBjb3Zlcjogc3RyaW5nXG4gICAgICBwbG90OiBzdHJpbmdcbiAgICAgIGdlbnJlOiBzdHJpbmdcbiAgICAgIHllYXI6IHN0cmluZ1xuICAgICAgZXBpc29kZV9kZXRhaWxzOiB7XG4gICAgICAgIFtlcGlzb2RlSWQ6IHN0cmluZ106IHtcbiAgICAgICAgICB0aXRsZTogc3RyaW5nXG4gICAgICAgICAgcGxvdDogc3RyaW5nXG4gICAgICAgICAgZXBpc29kZV9udW06IHN0cmluZ1xuICAgICAgICAgIHNlYXNvbl9udW06IHN0cmluZ1xuICAgICAgICAgIGR1cmF0aW9uOiBzdHJpbmdcbiAgICAgICAgICBjdXN0b21fc2lkOiBzdHJpbmdcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5pbnRlcmZhY2UgTW92aWVSZXNwb25zZSB7XG4gIHZvZDoge1xuICAgIFttb3ZpZUlkOiBzdHJpbmddOiB7XG4gICAgICBuYW1lOiBzdHJpbmdcbiAgICAgIGNvdmVyOiBzdHJpbmdcbiAgICAgIHBsb3Q6IHN0cmluZ1xuICAgICAgZ2VucmU6IHN0cmluZ1xuICAgICAgeWVhcjogc3RyaW5nXG4gICAgICBkdXJhdGlvbjogc3RyaW5nXG4gICAgfVxuICB9XG59XG5cbmludGVyZmFjZSBMaXZlU3RyZWFtUmVzcG9uc2Uge1xuICBsaXZlOiB7XG4gICAgW2NoYW5uZWxJZDogc3RyaW5nXToge1xuICAgICAgbmFtZTogc3RyaW5nXG4gICAgICBzdHJlYW1faWNvbjogc3RyaW5nXG4gICAgICBlcGdfY2hhbm5lbF9pZDogc3RyaW5nXG4gICAgfVxuICB9XG59XG5cbi8vIEFQSSBDYWxsc1xuZXhwb3J0IGNvbnN0IGdldEFsbFNlcmllcyA9IGFzeW5jICgpOiBQcm9taXNlPGFueVtdPiA9PiB7XG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpUmVxdWVzdDxhbnk+KFwiZ2V0X3Nlcmllc1wiKVxuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzcG9uc2Uuc2VyaWVzIHx8IHt9KS5tYXAoKFtpZCwgc2VyaWVzXSkgPT4gKHsgaWQsIC4uLnNlcmllcyB9KSlcbn1cblxuZXhwb3J0IGNvbnN0IGdldEFsbE1vdmllcyA9IGFzeW5jICgpOiBQcm9taXNlPGFueVtdPiA9PiB7XG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpUmVxdWVzdDxhbnk+KFwiZ2V0X3ZvZFwiKVxuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzcG9uc2Uudm9kIHx8IHt9KS5tYXAoKFtpZCwgbW92aWVdKSA9PiAoeyBpZCwgLi4ubW92aWUgfSkpXG59XG5cbmV4cG9ydCBjb25zdCBnZXRBbGxMaXZlU3RyZWFtcyA9IGFzeW5jICgpOiBQcm9taXNlPGFueVtdPiA9PiB7XG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpUmVxdWVzdDxhbnk+KFwiZ2V0X2xpdmVfc3RyZWFtc1wiKVxuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVzcG9uc2UubGl2ZSB8fCB7fSkubWFwKChbaWQsIGNoYW5uZWxdKSA9PiAoeyBpZCwgLi4uY2hhbm5lbCB9KSlcbn1cblxuZXhwb3J0IGNvbnN0IGdldFNlcmllc0luZm8gPSBhc3luYyAoc2VyaWVzSWQ6IHN0cmluZyk6IFByb21pc2U8YW55PiA9PiB7XG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpUmVxdWVzdDxhbnk+KEFQSV9FTkRQT0lOVFMuR0VUX1NFUklFU19JTkZPLCB7IHNlcmllc19pZDogc2VyaWVzSWQgfSlcbiAgcmV0dXJuIHJlc3BvbnNlXG59XG5cbmV4cG9ydCBjb25zdCBnZXRNb3ZpZUluZm8gPSBhc3luYyAodm9kSWQ6IHN0cmluZyk6IFByb21pc2U8YW55PiA9PiB7XG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpUmVxdWVzdDxhbnk+KEFQSV9FTkRQT0lOVFMuR0VUX01PVklFX0lORk8sIHsgdm9kX2lkOiB2b2RJZCB9KVxuICByZXR1cm4gcmVzcG9uc2Vcbn1cblxuZXhwb3J0IGNvbnN0IHNlYXJjaENvbnRlbnQgPSBhc3luYyAocXVlcnk6IHN0cmluZyk6IFByb21pc2U8Q29udGVudEl0ZW1bXT4gPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpUmVxdWVzdDxhbnk+KEFQSV9FTkRQT0lOVFMuU0VBUkNILCB7IHF1ZXJ5OiBxdWVyeSB9KVxuXG4gICAgaWYgKCFyZXNwb25zZSB8fCAhcmVzcG9uc2UuZGF0YSkge1xuICAgICAgcmV0dXJuIFtdXG4gICAgfVxuXG4gICAgY29uc3Qgc2VyaWVzUmVzdWx0cyA9IE9iamVjdC5lbnRyaWVzKHJlc3BvbnNlLmRhdGEuc2VyaWVzIHx8IHt9KS5tYXAoKFtpZCwgc2VyaWVzXSkgPT5cbiAgICAgIG1hcFNlcmllc1RvQ29udGVudCh7IGlkLCAuLi5zZXJpZXMgfSksXG4gICAgKVxuICAgIGNvbnN0IG1vdmllUmVzdWx0cyA9IE9iamVjdC5lbnRyaWVzKHJlc3BvbnNlLmRhdGEudm9kIHx8IHt9KS5tYXAoKFtpZCwgbW92aWVdKSA9PlxuICAgICAgbWFwTW92aWVUb0NvbnRlbnQoeyBpZCwgLi4ubW92aWUgfSksXG4gICAgKVxuICAgIGNvbnN0IGNoYW5uZWxSZXN1bHRzID0gT2JqZWN0LmVudHJpZXMocmVzcG9uc2UuZGF0YS5saXZlIHx8IHt9KS5tYXAoKFtpZCwgY2hhbm5lbF0pID0+XG4gICAgICBtYXBDaGFubmVsVG9Db250ZW50KHsgaWQsIC4uLmNoYW5uZWwgfSksXG4gICAgKVxuXG4gICAgcmV0dXJuIFsuLi5zZXJpZXNSZXN1bHRzLCAuLi5tb3ZpZVJlc3VsdHMsIC4uLmNoYW5uZWxSZXN1bHRzXVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJTZWFyY2ggZmFpbGVkOlwiLCBlcnJvcilcbiAgICByZXR1cm4gW11cbiAgfVxufVxuXG4vLyBEYXRhIE1hcHBpbmcgRnVuY3Rpb25zXG5leHBvcnQgY29uc3QgbWFwU2VyaWVzVG9Db250ZW50ID0gKHNlcmllczogYW55KTogQ29udGVudEl0ZW0gPT4gKHtcbiAgaWQ6IHNlcmllcy5pZCxcbiAgdGl0bGU6IHNlcmllcy5uYW1lLFxuICBkZXNjcmlwdGlvbjogc2VyaWVzLnBsb3QsXG4gIHRodW1ibmFpbDogc2VyaWVzLmNvdmVyLFxuICB0eXBlOiBcInNlcmllc1wiLFxuICBnZW5yZTogc2VyaWVzLmdlbnJlLFxuICB5ZWFyOiBzZXJpZXMueWVhcixcbn0pXG5cbmV4cG9ydCBjb25zdCBtYXBNb3ZpZVRvQ29udGVudCA9IChtb3ZpZTogYW55KTogQ29udGVudEl0ZW0gPT4gKHtcbiAgaWQ6IG1vdmllLmlkLFxuICB0aXRsZTogbW92aWUubmFtZSxcbiAgZGVzY3JpcHRpb246IG1vdmllLnBsb3QsXG4gIHRodW1ibmFpbDogbW92aWUuY292ZXIsXG4gIHR5cGU6IFwibW92aWVcIixcbiAgZ2VucmU6IG1vdmllLmdlbnJlLFxuICB5ZWFyOiBtb3ZpZS55ZWFyLFxuICBkdXJhdGlvbjogbW92aWUuZHVyYXRpb24sXG59KVxuXG5leHBvcnQgY29uc3QgbWFwQ2hhbm5lbFRvQ29udGVudCA9IChjaGFubmVsOiBhbnkpOiBDb250ZW50SXRlbSA9PiAoe1xuICBpZDogY2hhbm5lbC5pZCxcbiAgdGl0bGU6IGNoYW5uZWwubmFtZSxcbiAgZGVzY3JpcHRpb246IFwiXCIsXG4gIHRodW1ibmFpbDogY2hhbm5lbC5zdHJlYW1faWNvbixcbiAgdHlwZTogXCJjaGFubmVsXCIsXG59KVxuXG5leHBvcnQgY29uc3QgbWFwU2VyaWVzRGV0YWlsc1RvQ29udGVudCA9IChzZXJpZXNEZXRhaWxzOiBhbnkpOiBDb250ZW50SXRlbSA9PiB7XG4gIGNvbnN0IHNlcmllcyA9IHNlcmllc0RldGFpbHMuaW5mb1xuICBjb25zdCBlcGlzb2RlczogRXBpc29kZVtdID0gT2JqZWN0LmVudHJpZXMoc2VyaWVzRGV0YWlscy5lcGlzb2RlcyB8fCB7fSkubWFwKFxuICAgIChbZXBpc29kZUlkLCBlcGlzb2RlXTogW3N0cmluZywgYW55XSkgPT4gKHtcbiAgICAgIGlkOiBlcGlzb2RlSWQsXG4gICAgICB0aXRsZTogZXBpc29kZS50aXRsZSxcbiAgICAgIGRlc2NyaXB0aW9uOiBlcGlzb2RlLnBsb3QsXG4gICAgICBkdXJhdGlvbjogZXBpc29kZS5kdXJhdGlvbixcbiAgICB9KSxcbiAgKVxuXG4gIHJldHVybiB7XG4gICAgaWQ6IHNlcmllcy5pZCxcbiAgICB0aXRsZTogc2VyaWVzLm5hbWUsXG4gICAgZGVzY3JpcHRpb246IHNlcmllcy5wbG90LFxuICAgIHRodW1ibmFpbDogc2VyaWVzLmNvdmVyLFxuICAgIHR5cGU6IFwic2VyaWVzXCIsXG4gICAgZ2VucmU6IHNlcmllcy5nZW5yZSxcbiAgICB5ZWFyOiBzZXJpZXMueWVhcixcbiAgICBlcGlzb2RlczogZXBpc29kZXMsXG4gIH1cbn1cblxuLy8gTG9jYWwgU3RvcmFnZSBGdW5jdGlvbnNcbmNvbnN0IFBST0dSRVNTX0tFWSA9IFwiY29udGVudFByb2dyZXNzXCJcblxuZXhwb3J0IGNvbnN0IHNhdmVDb250ZW50UHJvZ3Jlc3MgPSAoY29udGVudElkOiBzdHJpbmcsIGN1cnJlbnRUaW1lOiBudW1iZXIsIGR1cmF0aW9uOiBudW1iZXIsIGVwaXNvZGVJZD86IHN0cmluZykgPT4ge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuXG5cbiAgdHJ5IHtcbiAgICBjb25zdCBwcm9ncmVzc0RhdGEgPSBKU09OLnBhcnNlKGxvY2FsU3RvcmFnZS5nZXRJdGVtKFBST0dSRVNTX0tFWSkgfHwgXCJ7fVwiKVxuICAgIHByb2dyZXNzRGF0YVtjb250ZW50SWQgKyAoZXBpc29kZUlkID8gYF8ke2VwaXNvZGVJZH1gIDogXCJcIildID0geyBjdXJyZW50VGltZSwgZHVyYXRpb24gfVxuICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFBST0dSRVNTX0tFWSwgSlNPTi5zdHJpbmdpZnkocHJvZ3Jlc3NEYXRhKSlcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIHNhdmUgY29udGVudCBwcm9ncmVzczpcIiwgZXJyb3IpXG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGdldENvbnRlbnRDdXJyZW50VGltZSA9IChjb250ZW50SWQ6IHN0cmluZywgZXBpc29kZUlkPzogc3RyaW5nKTogbnVtYmVyIHwgbnVsbCA9PiB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSByZXR1cm4gbnVsbFxuXG4gIHRyeSB7XG4gICAgY29uc3QgcHJvZ3Jlc3NEYXRhID0gSlNPTi5wYXJzZShsb2NhbFN0b3JhZ2UuZ2V0SXRlbShQUk9HUkVTU19LRVkpIHx8IFwie31cIilcbiAgICBjb25zdCBwcm9ncmVzcyA9IHByb2dyZXNzRGF0YVtjb250ZW50SWQgKyAoZXBpc29kZUlkID8gYF8ke2VwaXNvZGVJZH1gIDogXCJcIildXG4gICAgcmV0dXJuIHByb2dyZXNzID8gcHJvZ3Jlc3MuY3VycmVudFRpbWUgOiBudWxsXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBnZXQgY29udGVudCBwcm9ncmVzczpcIiwgZXJyb3IpXG4gICAgcmV0dXJuIG51bGxcbiAgfVxufVxuXG4vLyBUZXN0IENvbm5lY3Rpb25cbmV4cG9ydCBjb25zdCB0ZXN0Q29ubmVjdGlvbiA9IGFzeW5jICgpOiBQcm9taXNlPGJvb2xlYW4+ID0+IHtcbiAgdHJ5IHtcbiAgICAvLyBBdHRlbXB0IHRvIGZldGNoIHNlcmllcyAoYSBiYXNpYyBBUEkgY2FsbClcbiAgICBhd2FpdCBnZXRBbGxTZXJpZXMoKVxuICAgIHJldHVybiB0cnVlXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihcIkNvbm5lY3Rpb24gdGVzdCBmYWlsZWQ6XCIsIGVycm9yKVxuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbi8vIEVycm9yIE1lc3NhZ2UgSGVscGVyXG5leHBvcnQgY29uc3QgZ2V0RXJyb3JNZXNzYWdlID0gKGVycm9yOiBhbnkpOiBzdHJpbmcgPT4ge1xuICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBBdXRoZW50aWNhdGlvbkVycm9yKSB7XG4gICAgcmV0dXJuIFwiRmFsaGEgbmEgYXV0ZW50aWNhw6fDo28uIFZlcmlmaXF1ZSBzdWFzIGNyZWRlbmNpYWlzLlwiXG4gIH0gZWxzZSBpZiAoZXJyb3IgaW5zdGFuY2VvZiBOb3RGb3VuZEVycm9yKSB7XG4gICAgcmV0dXJuIFwiUmVjdXJzbyBuw6NvIGVuY29udHJhZG8uXCJcbiAgfSBlbHNlIGlmIChlcnJvciBpbnN0YW5jZW9mIEFwaUVycm9yKSB7XG4gICAgcmV0dXJuIGBFcnJvIG5hIEFQSTogJHtlcnJvci5tZXNzYWdlfWBcbiAgfSBlbHNlIGlmIChlcnJvciBpbnN0YW5jZW9mIE5ldHdvcmtFcnJvcikge1xuICAgIHJldHVybiBcIkVycm8gZGUgcmVkZS4gVmVyaWZpcXVlIHN1YSBjb25leMOjbyBjb20gYSBpbnRlcm5ldC5cIlxuICB9IGVsc2UgaWYgKGVycm9yIGluc3RhbmNlb2YgVHlwZUVycm9yICYmIGVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoXCJGYWlsZWQgdG8gZmV0Y2hcIikpIHtcbiAgICByZXR1cm4gXCJFcnJvIGFvIGNvbmVjdGFyIGFvIHNlcnZpZG9yLiBWZXJpZmlxdWUgYSBVUkwgZSBzdWEgY29uZXjDo28uXCJcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gXCJPY29ycmV1IHVtIGVycm8gaW5lc3BlcmFkby5cIlxuICB9XG59XG4iXSwibmFtZXMiOlsiQXV0aGVudGljYXRpb25FcnJvciIsIkVycm9yIiwiY29uc3RydWN0b3IiLCJtZXNzYWdlIiwibmFtZSIsIk5vdEZvdW5kRXJyb3IiLCJBcGlFcnJvciIsInN0YXR1c0NvZGUiLCJOZXR3b3JrRXJyb3IiLCJnZXRDcmVkZW50aWFscyIsInN0b3JlZENvbmZpZyIsImxvY2FsU3RvcmFnZSIsImdldEl0ZW0iLCJjcmVkZW50aWFscyIsIkpTT04iLCJwYXJzZSIsImZvcmNlSHR0cHMiLCJhcGlVcmwiLCJ0b0xvd2VyQ2FzZSIsInN0YXJ0c1dpdGgiLCJyZXBsYWNlIiwiZXJyb3IiLCJjb25zb2xlIiwiYXBpUmVxdWVzdCIsImVuZHBvaW50IiwicGFyYW1zIiwicmV0cmllcyIsInVzZXJuYW1lIiwicGFzc3dvcmQiLCJ1cmwiLCJVUkwiLCJ3aW5kb3ciLCJsb2NhdGlvbiIsInByb3RvY29sIiwid2FybiIsInF1ZXJ5UGFyYW1zIiwiVVJMU2VhcmNoUGFyYW1zIiwiYWN0aW9uIiwiZnVsbFVybCIsInRvU3RyaW5nIiwicHJveHlVcmwiLCJwcm9jZXNzIiwiZW52IiwiQ09SU19QUk9YWSIsIlVTRV9QUk9YWSIsInJlc3BvbnNlIiwiZmV0Y2giLCJzaWduYWwiLCJBYm9ydFNpZ25hbCIsInRpbWVvdXQiLCJoZWFkZXJzIiwib2siLCJzdGF0dXMiLCJzdGF0dXNUZXh0IiwiZGF0YSIsImpzb24iLCJUeXBlRXJyb3IiLCJlcnJvck1lc3NhZ2UiLCJpbmNsdWRlcyIsImxvZyIsIlByb21pc2UiLCJyZXNvbHZlIiwic2V0VGltZW91dCIsImdldFN0cmVhbVVybCIsInN0cmVhbUlkIiwic3RyZWFtVHlwZSIsImVwaXNvZGVJZCIsImJhc2VVcmwiLCJBUElfRU5EUE9JTlRTIiwiR0VUX0FMTF9TRVJJRVMiLCJHRVRfQUxMX01PVklFUyIsIkdFVF9BTExfTElWRV9TVFJFQU1TIiwiR0VUX1NFUklFU19JTkZPIiwiR0VUX01PVklFX0lORk8iLCJTRUFSQ0giLCJnZXRBbGxTZXJpZXMiLCJPYmplY3QiLCJlbnRyaWVzIiwic2VyaWVzIiwibWFwIiwiaWQiLCJnZXRBbGxNb3ZpZXMiLCJ2b2QiLCJtb3ZpZSIsImdldEFsbExpdmVTdHJlYW1zIiwibGl2ZSIsImNoYW5uZWwiLCJnZXRTZXJpZXNJbmZvIiwic2VyaWVzSWQiLCJzZXJpZXNfaWQiLCJnZXRNb3ZpZUluZm8iLCJ2b2RJZCIsInZvZF9pZCIsInNlYXJjaENvbnRlbnQiLCJxdWVyeSIsInNlcmllc1Jlc3VsdHMiLCJtYXBTZXJpZXNUb0NvbnRlbnQiLCJtb3ZpZVJlc3VsdHMiLCJtYXBNb3ZpZVRvQ29udGVudCIsImNoYW5uZWxSZXN1bHRzIiwibWFwQ2hhbm5lbFRvQ29udGVudCIsInRpdGxlIiwiZGVzY3JpcHRpb24iLCJwbG90IiwidGh1bWJuYWlsIiwiY292ZXIiLCJ0eXBlIiwiZ2VucmUiLCJ5ZWFyIiwiZHVyYXRpb24iLCJzdHJlYW1faWNvbiIsIm1hcFNlcmllc0RldGFpbHNUb0NvbnRlbnQiLCJzZXJpZXNEZXRhaWxzIiwiaW5mbyIsImVwaXNvZGVzIiwiZXBpc29kZSIsIlBST0dSRVNTX0tFWSIsInNhdmVDb250ZW50UHJvZ3Jlc3MiLCJjb250ZW50SWQiLCJjdXJyZW50VGltZSIsInByb2dyZXNzRGF0YSIsInNldEl0ZW0iLCJzdHJpbmdpZnkiLCJnZXRDb250ZW50Q3VycmVudFRpbWUiLCJwcm9ncmVzcyIsInRlc3RDb25uZWN0aW9uIiwiZ2V0RXJyb3JNZXNzYWdlIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/api-service.ts\n"));

/***/ })

});