"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/api-service.ts":
/*!****************************!*\
  !*** ./lib/api-service.ts ***!
  \****************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ApiError: () => (/* binding */ ApiError),\n/* harmony export */   AuthenticationError: () => (/* binding */ AuthenticationError),\n/* harmony export */   NetworkError: () => (/* binding */ NetworkError),\n/* harmony export */   NotFoundError: () => (/* binding */ NotFoundError),\n/* harmony export */   getAllLiveStreams: () => (/* binding */ getAllLiveStreams),\n/* harmony export */   getAllMovies: () => (/* binding */ getAllMovies),\n/* harmony export */   getAllSeries: () => (/* binding */ getAllSeries),\n/* harmony export */   getContentCurrentTime: () => (/* binding */ getContentCurrentTime),\n/* harmony export */   getCredentials: () => (/* binding */ getCredentials),\n/* harmony export */   getErrorMessage: () => (/* binding */ getErrorMessage),\n/* harmony export */   getMovieInfo: () => (/* binding */ getMovieInfo),\n/* harmony export */   getSeriesInfo: () => (/* binding */ getSeriesInfo),\n/* harmony export */   getStreamUrl: () => (/* binding */ getStreamUrl),\n/* harmony export */   mapChannelToContent: () => (/* binding */ mapChannelToContent),\n/* harmony export */   mapMovieToContent: () => (/* binding */ mapMovieToContent),\n/* harmony export */   mapSeriesDetailsToContent: () => (/* binding */ mapSeriesDetailsToContent),\n/* harmony export */   mapSeriesToContent: () => (/* binding */ mapSeriesToContent),\n/* harmony export */   saveContentProgress: () => (/* binding */ saveContentProgress),\n/* harmony export */   searchContent: () => (/* binding */ searchContent),\n/* harmony export */   testConnection: () => (/* binding */ testConnection)\n/* harmony export */ });\n// Update the ApiCredentials interface to include forceHttps\n// Custom error classes\nclass AuthenticationError extends Error {\n    constructor(message = \"Authentication failed\"){\n        super(message);\n        this.name = \"AuthenticationError\";\n    }\n}\nclass NotFoundError extends Error {\n    constructor(message = \"Resource not found\"){\n        super(message);\n        this.name = \"NotFoundError\";\n    }\n}\nclass ApiError extends Error {\n    constructor(message = \"API error\", statusCode){\n        super(message);\n        this.name = \"ApiError\";\n        this.statusCode = statusCode;\n    }\n}\nclass NetworkError extends Error {\n    constructor(message = \"Network error\"){\n        super(message);\n        this.name = \"NetworkError\";\n    }\n}\n// Update the getCredentials function to handle the forceHttps option\nconst getCredentials = ()=>{\n    if (false) {}\n    const storedConfig = localStorage.getItem(\"streamConfig\");\n    if (!storedConfig) return null;\n    try {\n        const credentials = JSON.parse(storedConfig);\n        // If forceHttps is enabled, ensure the URL uses HTTPS\n        if (credentials.forceHttps && credentials.apiUrl.toLowerCase().startsWith(\"http:\")) {\n            credentials.apiUrl = credentials.apiUrl.replace(/^http:/i, \"https:\");\n        }\n        return credentials;\n    } catch (error) {\n        console.error(\"Failed to parse stored credentials:\", error);\n        return null;\n    }\n};\n// Update the apiRequest function to better handle mixed content errors and add proxy support\nasync function apiRequest(endpoint) {\n    let params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, retries = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 2;\n    const credentials = getCredentials();\n    if (!credentials) {\n        throw new AuthenticationError(\"Credenciais não encontradas. Configure o aplicativo primeiro.\");\n    }\n    const { apiUrl, username, password } = credentials;\n    // Build URL with credentials and params\n    let url;\n    try {\n        url = new URL(apiUrl);\n    } catch (error) {\n        throw new Error(\"URL inv\\xe1lida: \".concat(apiUrl, \". Verifique a configura\\xe7\\xe3o.\"));\n    }\n    // Add authentication params and action\n    const queryParams = new URLSearchParams({\n        username,\n        password,\n        action: endpoint,\n        ...params\n    });\n    let fullUrl = \"\".concat(url.toString(), \"?\").concat(queryParams.toString());\n    // Use a proxy to bypass CORS if necessary\n    const proxyUrl = \"https://cors-anywhere.herokuapp.com/\";\n    if (true) {\n        fullUrl = \"\".concat(proxyUrl).concat(fullUrl);\n    }\n    try {\n        const response = await fetch(fullUrl, {\n            method: \"GET\",\n            mode:  true ? \"cors\" : 0,\n            credentials: \"omit\",\n            headers: {\n                \"accept\": \"application/json\",\n                \"accept-language\": \"pt-BR,pt;q=0.9,en-US;q=0.8,en;q=0.7\"\n            },\n            signal: AbortSignal.timeout(30000)\n        });\n        console.log(\"API Response:\", response);\n        // Handle different HTTP status codes\n        if (!response.ok) {\n            if (response.status === 401 || response.status === 403) {\n                throw new AuthenticationError();\n            } else if (response.status === 404) {\n                throw new NotFoundError();\n            } else {\n                throw new ApiError(\"Erro na API: \".concat(response.statusText), response.status);\n            }\n        }\n        // Parse JSON response (only works with \"cors\" mode)\n        if (true) {\n            const data = await response.json();\n            if (data && data.error) {\n                throw new ApiError(\"Erro na API: \".concat(data.error));\n            }\n            return data;\n        }\n        // Return empty response for \"no-cors\" mode\n        console.warn(\"Modo 'no-cors' ativo. Não é possível acessar o corpo da resposta.\");\n        return {};\n    } catch (error) {\n        // Handle timeout errors\n        if (error.name === \"AbortError\") {\n            console.error(\"A requisição demorou muito e foi abortada.\");\n            throw new NetworkError(\"A requisição excedeu o tempo limite. Tente novamente.\");\n        }\n        // Check specifically for mixed content errors\n        if (error instanceof TypeError) {\n            const errorMessage = error.message.toLowerCase();\n            if (errorMessage.includes(\"mixed content\") || errorMessage.includes(\"blocked\") && errorMessage.includes(\"insecure\")) {\n                throw new NetworkError(\"Erro de conteúdo misto: seu navegador bloqueou a requisição HTTP em um site HTTPS. \" + \"Tente ativar 'Forçar HTTPS' nas configurações ou use um servidor com HTTPS.\");\n            }\n            // Handle network errors and implement retry logic\n            if (errorMessage.includes(\"fetch\")) {\n                // Network error\n                if (retries > 0) {\n                    console.log(\"Retry attempt (\".concat(retries, \" remaining) for \").concat(fullUrl));\n                    // Exponential backoff: wait longer between retries\n                    await new Promise((resolve)=>setTimeout(resolve, (3 - retries) * 1000));\n                    return apiRequest(endpoint, params, retries - 1);\n                }\n                throw new NetworkError();\n            }\n        }\n        // Re-throw other errors\n        throw error;\n    }\n}\n// Update the getStreamUrl function to handle HTTPS\nconst getStreamUrl = (streamId, streamType, episodeId)=>{\n    const credentials = getCredentials();\n    if (!credentials) {\n        throw new AuthenticationError(\"Credenciais não encontradas. Configure o aplicativo primeiro.\");\n    }\n    const { apiUrl, username, password, forceHttps } = credentials;\n    let baseUrl = apiUrl.replace(\"player_api.php\", \"\");\n    // If forceHttps is enabled, ensure the URL uses HTTPS\n    if (forceHttps && baseUrl.toLowerCase().startsWith(\"http:\")) {\n        baseUrl = baseUrl.replace(/^http:/i, \"https:\");\n    }\n    if (streamType === \"live\") {\n        return \"\".concat(baseUrl, \"live/\").concat(username, \"/\").concat(password, \"/\").concat(streamId, \".ts\");\n    } else if (streamType === \"movie\") {\n        return \"\".concat(baseUrl, \"movie/\").concat(username, \"/\").concat(password, \"/\").concat(streamId, \".mp4\");\n    } else if (streamType === \"series\" && episodeId) {\n        return \"\".concat(baseUrl, \"series/\").concat(username, \"/\").concat(password, \"/\").concat(streamId, \"/\").concat(episodeId, \".mp4\");\n    }\n    throw new Error(\"Tipo de stream inválido ou ID de episódio ausente para séries\");\n};\n// API Endpoints and Data Mapping\nconst API_ENDPOINTS = {\n    GET_ALL_SERIES: \"get_series\",\n    GET_ALL_MOVIES: \"get_vod\",\n    GET_ALL_LIVE_STREAMS: \"get_live_streams\",\n    GET_SERIES_INFO: \"get_series_info\",\n    GET_MOVIE_INFO: \"get_vod_info\",\n    SEARCH: \"search\"\n};\n// API Calls\nconst getAllSeries = async ()=>{\n    const response = await apiRequest(\"get_series\");\n    return Object.entries(response.series || {}).map((param)=>{\n        let [id, series] = param;\n        return {\n            id,\n            ...series\n        };\n    });\n};\nconst getAllMovies = async ()=>{\n    const response = await apiRequest(\"get_vod\");\n    return Object.entries(response.vod || {}).map((param)=>{\n        let [id, movie] = param;\n        return {\n            id,\n            ...movie\n        };\n    });\n};\nconst getAllLiveStreams = async ()=>{\n    const response = await apiRequest(\"get_live_streams\");\n    return Object.entries(response.live || {}).map((param)=>{\n        let [id, channel] = param;\n        return {\n            id,\n            ...channel\n        };\n    });\n};\nconst getSeriesInfo = async (seriesId)=>{\n    const response = await apiRequest(API_ENDPOINTS.GET_SERIES_INFO, {\n        series_id: seriesId\n    });\n    return response;\n};\nconst getMovieInfo = async (vodId)=>{\n    const response = await apiRequest(API_ENDPOINTS.GET_MOVIE_INFO, {\n        vod_id: vodId\n    });\n    return response;\n};\nconst searchContent = async (query)=>{\n    try {\n        const response = await apiRequest(API_ENDPOINTS.SEARCH, {\n            query: query\n        });\n        if (!response || !response.data) {\n            return [];\n        }\n        const seriesResults = Object.entries(response.data.series || {}).map((param)=>{\n            let [id, series] = param;\n            return mapSeriesToContent({\n                id,\n                ...series\n            });\n        });\n        const movieResults = Object.entries(response.data.vod || {}).map((param)=>{\n            let [id, movie] = param;\n            return mapMovieToContent({\n                id,\n                ...movie\n            });\n        });\n        const channelResults = Object.entries(response.data.live || {}).map((param)=>{\n            let [id, channel] = param;\n            return mapChannelToContent({\n                id,\n                ...channel\n            });\n        });\n        return [\n            ...seriesResults,\n            ...movieResults,\n            ...channelResults\n        ];\n    } catch (error) {\n        console.error(\"Search failed:\", error);\n        return [];\n    }\n};\n// Data Mapping Functions\nconst mapSeriesToContent = (series)=>({\n        id: series.id,\n        title: series.name,\n        description: series.plot,\n        thumbnail: series.cover,\n        type: \"series\",\n        genre: series.genre,\n        year: series.year\n    });\nconst mapMovieToContent = (movie)=>({\n        id: movie.id,\n        title: movie.name,\n        description: movie.plot,\n        thumbnail: movie.cover,\n        type: \"movie\",\n        genre: movie.genre,\n        year: movie.year,\n        duration: movie.duration\n    });\nconst mapChannelToContent = (channel)=>({\n        id: channel.id,\n        title: channel.name,\n        description: \"\",\n        thumbnail: channel.stream_icon,\n        type: \"channel\"\n    });\nconst mapSeriesDetailsToContent = (seriesDetails)=>{\n    const series = seriesDetails.info;\n    const episodes = Object.entries(seriesDetails.episodes || {}).map((param)=>{\n        let [episodeId, episode] = param;\n        return {\n            id: episodeId,\n            title: episode.title,\n            description: episode.plot,\n            duration: episode.duration\n        };\n    });\n    return {\n        id: series.id,\n        title: series.name,\n        description: series.plot,\n        thumbnail: series.cover,\n        type: \"series\",\n        genre: series.genre,\n        year: series.year,\n        episodes: episodes\n    };\n};\n// Local Storage Functions\nconst PROGRESS_KEY = \"contentProgress\";\nconst saveContentProgress = (contentId, currentTime, duration, episodeId)=>{\n    if (false) {}\n    try {\n        const progressData = JSON.parse(localStorage.getItem(PROGRESS_KEY) || \"{}\");\n        progressData[contentId + (episodeId ? \"_\".concat(episodeId) : \"\")] = {\n            currentTime,\n            duration\n        };\n        localStorage.setItem(PROGRESS_KEY, JSON.stringify(progressData));\n    } catch (error) {\n        console.error(\"Failed to save content progress:\", error);\n    }\n};\nconst getContentCurrentTime = (contentId, episodeId)=>{\n    if (false) {}\n    try {\n        const progressData = JSON.parse(localStorage.getItem(PROGRESS_KEY) || \"{}\");\n        const progress = progressData[contentId + (episodeId ? \"_\".concat(episodeId) : \"\")];\n        return progress ? progress.currentTime : null;\n    } catch (error) {\n        console.error(\"Failed to get content progress:\", error);\n        return null;\n    }\n};\n// Test Connection\nconst testConnection = async ()=>{\n    try {\n        // Attempt to fetch series (a basic API call)\n        await getAllSeries();\n        return true;\n    } catch (error) {\n        console.error(\"Connection test failed:\", error);\n        return false;\n    }\n};\n// Error Message Helper\nconst getErrorMessage = (error)=>{\n    if (error instanceof AuthenticationError) {\n        return \"Falha na autenticação. Verifique suas credenciais.\";\n    } else if (error instanceof NotFoundError) {\n        return \"Recurso não encontrado.\";\n    } else if (error instanceof ApiError) {\n        return \"Erro na API: \".concat(error.message);\n    } else if (error instanceof NetworkError) {\n        return \"Erro de rede. Verifique sua conexão com a internet.\";\n    } else if (error instanceof TypeError && error.message.includes(\"Failed to fetch\")) {\n        return \"Erro ao conectar ao servidor. Verifique a URL e sua conexão.\";\n    } else {\n        return \"Ocorreu um erro inesperado.\";\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QU1vRyxrQkFBa0IsQ0FBQ3BHO0lBQzlCLElBQUlBLGlCQUFpQnJCLHFCQUFxQjtRQUN4QyxPQUFPO0lBQ1QsT0FBTyxJQUFJcUIsaUJBQWlCaEIsZUFBZTtRQUN6QyxPQUFPO0lBQ1QsT0FBTyxJQUFJZ0IsaUJBQWlCZixVQUFVO1FBQ3BDLE9BQU8sZ0JBQThCLE9BQWRlLE1BQU1sQixPQUFPO0lBQ3RDLE9BQU8sSUFBSWtCLGlCQUFpQmIsY0FBYztRQUN4QyxPQUFPO0lBQ1QsT0FBTyxJQUFJYSxpQkFBaUIrQixhQUFhL0IsTUFBTWxCLE9BQU8sQ0FBQ21ELFFBQVEsQ0FBQyxvQkFBb0I7UUFDbEYsT0FBTztJQUNULE9BQU87UUFDTCxPQUFPO0lBQ1Q7QUFDRixFQUFDIiwic291cmNlcyI6WyIvVXNlcnMvaGVpdG9yLmNhbmRpZG8vRG9jdW1lbnRzL2lwdHYvaXB0di1hcHAvbGliL2FwaS1zZXJ2aWNlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFVwZGF0ZSB0aGUgQXBpQ3JlZGVudGlhbHMgaW50ZXJmYWNlIHRvIGluY2x1ZGUgZm9yY2VIdHRwc1xuZXhwb3J0IGludGVyZmFjZSBBcGlDcmVkZW50aWFscyB7XG4gIGFwaVVybDogc3RyaW5nXG4gIHVzZXJuYW1lOiBzdHJpbmdcbiAgcGFzc3dvcmQ6IHN0cmluZ1xuICBmb3JjZUh0dHBzPzogYm9vbGVhblxufVxuXG4vLyBDdXN0b20gZXJyb3IgY2xhc3Nlc1xuZXhwb3J0IGNsYXNzIEF1dGhlbnRpY2F0aW9uRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UgPSBcIkF1dGhlbnRpY2F0aW9uIGZhaWxlZFwiKSB7XG4gICAgc3VwZXIobWVzc2FnZSlcbiAgICB0aGlzLm5hbWUgPSBcIkF1dGhlbnRpY2F0aW9uRXJyb3JcIlxuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBOb3RGb3VuZEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlID0gXCJSZXNvdXJjZSBub3QgZm91bmRcIikge1xuICAgIHN1cGVyKG1lc3NhZ2UpXG4gICAgdGhpcy5uYW1lID0gXCJOb3RGb3VuZEVycm9yXCJcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgQXBpRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIHB1YmxpYyBzdGF0dXNDb2RlOiBudW1iZXIgfCB1bmRlZmluZWRcblxuICBjb25zdHJ1Y3RvcihtZXNzYWdlID0gXCJBUEkgZXJyb3JcIiwgc3RhdHVzQ29kZT86IG51bWJlcikge1xuICAgIHN1cGVyKG1lc3NhZ2UpXG4gICAgdGhpcy5uYW1lID0gXCJBcGlFcnJvclwiXG4gICAgdGhpcy5zdGF0dXNDb2RlID0gc3RhdHVzQ29kZVxuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBOZXR3b3JrRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UgPSBcIk5ldHdvcmsgZXJyb3JcIikge1xuICAgIHN1cGVyKG1lc3NhZ2UpXG4gICAgdGhpcy5uYW1lID0gXCJOZXR3b3JrRXJyb3JcIlxuICB9XG59XG5cbi8vIFVwZGF0ZSB0aGUgZ2V0Q3JlZGVudGlhbHMgZnVuY3Rpb24gdG8gaGFuZGxlIHRoZSBmb3JjZUh0dHBzIG9wdGlvblxuZXhwb3J0IGNvbnN0IGdldENyZWRlbnRpYWxzID0gKCk6IEFwaUNyZWRlbnRpYWxzIHwgbnVsbCA9PiB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSByZXR1cm4gbnVsbFxuXG4gIGNvbnN0IHN0b3JlZENvbmZpZyA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKFwic3RyZWFtQ29uZmlnXCIpXG4gIGlmICghc3RvcmVkQ29uZmlnKSByZXR1cm4gbnVsbFxuXG4gIHRyeSB7XG4gICAgY29uc3QgY3JlZGVudGlhbHMgPSBKU09OLnBhcnNlKHN0b3JlZENvbmZpZykgYXMgQXBpQ3JlZGVudGlhbHNcblxuICAgIC8vIElmIGZvcmNlSHR0cHMgaXMgZW5hYmxlZCwgZW5zdXJlIHRoZSBVUkwgdXNlcyBIVFRQU1xuICAgIGlmIChjcmVkZW50aWFscy5mb3JjZUh0dHBzICYmIGNyZWRlbnRpYWxzLmFwaVVybC50b0xvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgoXCJodHRwOlwiKSkge1xuICAgICAgY3JlZGVudGlhbHMuYXBpVXJsID0gY3JlZGVudGlhbHMuYXBpVXJsLnJlcGxhY2UoL15odHRwOi9pLCBcImh0dHBzOlwiKVxuICAgIH1cblxuICAgIHJldHVybiBjcmVkZW50aWFsc1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gcGFyc2Ugc3RvcmVkIGNyZWRlbnRpYWxzOlwiLCBlcnJvcilcbiAgICByZXR1cm4gbnVsbFxuICB9XG59XG5cbi8vIFVwZGF0ZSB0aGUgYXBpUmVxdWVzdCBmdW5jdGlvbiB0byBiZXR0ZXIgaGFuZGxlIG1peGVkIGNvbnRlbnQgZXJyb3JzIGFuZCBhZGQgcHJveHkgc3VwcG9ydFxuYXN5bmMgZnVuY3Rpb24gYXBpUmVxdWVzdDxUPihlbmRwb2ludDogc3RyaW5nLCBwYXJhbXM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7fSwgcmV0cmllcyA9IDIpOiBQcm9taXNlPFQ+IHtcbiAgY29uc3QgY3JlZGVudGlhbHMgPSBnZXRDcmVkZW50aWFscygpXG4gIGlmICghY3JlZGVudGlhbHMpIHtcbiAgICB0aHJvdyBuZXcgQXV0aGVudGljYXRpb25FcnJvcihcIkNyZWRlbmNpYWlzIG7Do28gZW5jb250cmFkYXMuIENvbmZpZ3VyZSBvIGFwbGljYXRpdm8gcHJpbWVpcm8uXCIpXG4gIH1cblxuICBjb25zdCB7IGFwaVVybCwgdXNlcm5hbWUsIHBhc3N3b3JkIH0gPSBjcmVkZW50aWFsc1xuXG4gIC8vIEJ1aWxkIFVSTCB3aXRoIGNyZWRlbnRpYWxzIGFuZCBwYXJhbXNcbiAgbGV0IHVybDogVVJMXG4gIHRyeSB7XG4gICAgdXJsID0gbmV3IFVSTChhcGlVcmwpXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVUkwgaW52w6FsaWRhOiAke2FwaVVybH0uIFZlcmlmaXF1ZSBhIGNvbmZpZ3VyYcOnw6NvLmApXG4gIH1cblxuICAvLyBBZGQgYXV0aGVudGljYXRpb24gcGFyYW1zIGFuZCBhY3Rpb25cbiAgY29uc3QgcXVlcnlQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHtcbiAgICB1c2VybmFtZSxcbiAgICBwYXNzd29yZCxcbiAgICBhY3Rpb246IGVuZHBvaW50LFxuICAgIC4uLnBhcmFtcyxcbiAgfSlcblxuICBsZXQgZnVsbFVybCA9IGAke3VybC50b1N0cmluZygpfT8ke3F1ZXJ5UGFyYW1zLnRvU3RyaW5nKCl9YFxuXG4gIC8vIFVzZSBhIHByb3h5IHRvIGJ5cGFzcyBDT1JTIGlmIG5lY2Vzc2FyeVxuICBjb25zdCBwcm94eVVybCA9IFwiaHR0cHM6Ly9jb3JzLWFueXdoZXJlLmhlcm9rdWFwcC5jb20vXCJcbiAgaWYgKHRydWUpIHtcbiAgICBmdWxsVXJsID0gYCR7cHJveHlVcmx9JHtmdWxsVXJsfWBcbiAgfVxuXG4gIHRyeSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChmdWxsVXJsLCB7XG4gICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICBtb2RlOiB0cnVlID8gXCJjb3JzXCIgOiBcIm5vLWNvcnNcIiwgLy8gVXNlIFwiY29yc1wiIHdpdGggcHJveHlcbiAgICAgIGNyZWRlbnRpYWxzOiBcIm9taXRcIixcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgXCJhY2NlcHRcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgIFwiYWNjZXB0LWxhbmd1YWdlXCI6IFwicHQtQlIscHQ7cT0wLjksZW4tVVM7cT0wLjgsZW47cT0wLjdcIixcbiAgICAgIH0sXG4gICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQoMzAwMDApLCAvLyBUaW1lb3V0IGRlIDMwIHNlZ3VuZG9zXG4gICAgfSlcblxuICAgIGNvbnNvbGUubG9nKFwiQVBJIFJlc3BvbnNlOlwiLCByZXNwb25zZSlcblxuICAgIC8vIEhhbmRsZSBkaWZmZXJlbnQgSFRUUCBzdGF0dXMgY29kZXNcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MDEgfHwgcmVzcG9uc2Uuc3RhdHVzID09PSA0MDMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEF1dGhlbnRpY2F0aW9uRXJyb3IoKVxuICAgICAgfSBlbHNlIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQwNCkge1xuICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFcnJvcigpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgQXBpRXJyb3IoYEVycm8gbmEgQVBJOiAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCwgcmVzcG9uc2Uuc3RhdHVzKVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFBhcnNlIEpTT04gcmVzcG9uc2UgKG9ubHkgd29ya3Mgd2l0aCBcImNvcnNcIiBtb2RlKVxuICAgIGlmICh0cnVlKSB7XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpXG4gICAgICBpZiAoZGF0YSAmJiBkYXRhLmVycm9yKSB7XG4gICAgICAgIHRocm93IG5ldyBBcGlFcnJvcihgRXJybyBuYSBBUEk6ICR7ZGF0YS5lcnJvcn1gKVxuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGEgYXMgVFxuICAgIH1cblxuICAgIC8vIFJldHVybiBlbXB0eSByZXNwb25zZSBmb3IgXCJuby1jb3JzXCIgbW9kZVxuICAgIGNvbnNvbGUud2FybihcIk1vZG8gJ25vLWNvcnMnIGF0aXZvLiBOw6NvIMOpIHBvc3PDrXZlbCBhY2Vzc2FyIG8gY29ycG8gZGEgcmVzcG9zdGEuXCIpXG4gICAgcmV0dXJuIHt9IGFzIFRcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAvLyBIYW5kbGUgdGltZW91dCBlcnJvcnNcbiAgICBpZiAoZXJyb3IubmFtZSA9PT0gXCJBYm9ydEVycm9yXCIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJBIHJlcXVpc2nDp8OjbyBkZW1vcm91IG11aXRvIGUgZm9pIGFib3J0YWRhLlwiKVxuICAgICAgdGhyb3cgbmV3IE5ldHdvcmtFcnJvcihcIkEgcmVxdWlzacOnw6NvIGV4Y2VkZXUgbyB0ZW1wbyBsaW1pdGUuIFRlbnRlIG5vdmFtZW50ZS5cIilcbiAgICB9XG5cbiAgICAvLyBDaGVjayBzcGVjaWZpY2FsbHkgZm9yIG1peGVkIGNvbnRlbnQgZXJyb3JzXG4gICAgaWYgKGVycm9yIGluc3RhbmNlb2YgVHlwZUVycm9yKSB7XG4gICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBlcnJvci5tZXNzYWdlLnRvTG93ZXJDYXNlKClcblxuICAgICAgaWYgKFxuICAgICAgICBlcnJvck1lc3NhZ2UuaW5jbHVkZXMoXCJtaXhlZCBjb250ZW50XCIpIHx8XG4gICAgICAgIChlcnJvck1lc3NhZ2UuaW5jbHVkZXMoXCJibG9ja2VkXCIpICYmIGVycm9yTWVzc2FnZS5pbmNsdWRlcyhcImluc2VjdXJlXCIpKVxuICAgICAgKSB7XG4gICAgICAgIHRocm93IG5ldyBOZXR3b3JrRXJyb3IoXG4gICAgICAgICAgXCJFcnJvIGRlIGNvbnRlw7pkbyBtaXN0bzogc2V1IG5hdmVnYWRvciBibG9xdWVvdSBhIHJlcXVpc2nDp8OjbyBIVFRQIGVtIHVtIHNpdGUgSFRUUFMuIFwiICtcbiAgICAgICAgICAgIFwiVGVudGUgYXRpdmFyICdGb3LDp2FyIEhUVFBTJyBuYXMgY29uZmlndXJhw6fDtWVzIG91IHVzZSB1bSBzZXJ2aWRvciBjb20gSFRUUFMuXCIsXG4gICAgICAgIClcbiAgICAgIH1cblxuICAgICAgLy8gSGFuZGxlIG5ldHdvcmsgZXJyb3JzIGFuZCBpbXBsZW1lbnQgcmV0cnkgbG9naWNcbiAgICAgIGlmIChlcnJvck1lc3NhZ2UuaW5jbHVkZXMoXCJmZXRjaFwiKSkge1xuICAgICAgICAvLyBOZXR3b3JrIGVycm9yXG4gICAgICAgIGlmIChyZXRyaWVzID4gMCkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGBSZXRyeSBhdHRlbXB0ICgke3JldHJpZXN9IHJlbWFpbmluZykgZm9yICR7ZnVsbFVybH1gKVxuICAgICAgICAgIC8vIEV4cG9uZW50aWFsIGJhY2tvZmY6IHdhaXQgbG9uZ2VyIGJldHdlZW4gcmV0cmllc1xuICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsICgzIC0gcmV0cmllcykgKiAxMDAwKSlcbiAgICAgICAgICByZXR1cm4gYXBpUmVxdWVzdDxUPihlbmRwb2ludCwgcGFyYW1zLCByZXRyaWVzIC0gMSlcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgTmV0d29ya0Vycm9yKClcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZS10aHJvdyBvdGhlciBlcnJvcnNcbiAgICB0aHJvdyBlcnJvclxuICB9XG59XG5cbi8vIFVwZGF0ZSB0aGUgZ2V0U3RyZWFtVXJsIGZ1bmN0aW9uIHRvIGhhbmRsZSBIVFRQU1xuZXhwb3J0IGNvbnN0IGdldFN0cmVhbVVybCA9IChzdHJlYW1JZDogc3RyaW5nLCBzdHJlYW1UeXBlOiBcImxpdmVcIiB8IFwibW92aWVcIiB8IFwic2VyaWVzXCIsIGVwaXNvZGVJZD86IHN0cmluZyk6IHN0cmluZyA9PiB7XG4gIGNvbnN0IGNyZWRlbnRpYWxzID0gZ2V0Q3JlZGVudGlhbHMoKVxuICBpZiAoIWNyZWRlbnRpYWxzKSB7XG4gICAgdGhyb3cgbmV3IEF1dGhlbnRpY2F0aW9uRXJyb3IoXCJDcmVkZW5jaWFpcyBuw6NvIGVuY29udHJhZGFzLiBDb25maWd1cmUgbyBhcGxpY2F0aXZvIHByaW1laXJvLlwiKVxuICB9XG5cbiAgY29uc3QgeyBhcGlVcmwsIHVzZXJuYW1lLCBwYXNzd29yZCwgZm9yY2VIdHRwcyB9ID0gY3JlZGVudGlhbHNcbiAgbGV0IGJhc2VVcmwgPSBhcGlVcmwucmVwbGFjZShcInBsYXllcl9hcGkucGhwXCIsIFwiXCIpXG5cbiAgLy8gSWYgZm9yY2VIdHRwcyBpcyBlbmFibGVkLCBlbnN1cmUgdGhlIFVSTCB1c2VzIEhUVFBTXG4gIGlmIChmb3JjZUh0dHBzICYmIGJhc2VVcmwudG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKFwiaHR0cDpcIikpIHtcbiAgICBiYXNlVXJsID0gYmFzZVVybC5yZXBsYWNlKC9eaHR0cDovaSwgXCJodHRwczpcIilcbiAgfVxuXG4gIGlmIChzdHJlYW1UeXBlID09PSBcImxpdmVcIikge1xuICAgIHJldHVybiBgJHtiYXNlVXJsfWxpdmUvJHt1c2VybmFtZX0vJHtwYXNzd29yZH0vJHtzdHJlYW1JZH0udHNgXG4gIH0gZWxzZSBpZiAoc3RyZWFtVHlwZSA9PT0gXCJtb3ZpZVwiKSB7XG4gICAgcmV0dXJuIGAke2Jhc2VVcmx9bW92aWUvJHt1c2VybmFtZX0vJHtwYXNzd29yZH0vJHtzdHJlYW1JZH0ubXA0YFxuICB9IGVsc2UgaWYgKHN0cmVhbVR5cGUgPT09IFwic2VyaWVzXCIgJiYgZXBpc29kZUlkKSB7XG4gICAgcmV0dXJuIGAke2Jhc2VVcmx9c2VyaWVzLyR7dXNlcm5hbWV9LyR7cGFzc3dvcmR9LyR7c3RyZWFtSWR9LyR7ZXBpc29kZUlkfS5tcDRgXG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoXCJUaXBvIGRlIHN0cmVhbSBpbnbDoWxpZG8gb3UgSUQgZGUgZXBpc8OzZGlvIGF1c2VudGUgcGFyYSBzw6lyaWVzXCIpXG59XG5cbi8vIEFQSSBFbmRwb2ludHMgYW5kIERhdGEgTWFwcGluZ1xuY29uc3QgQVBJX0VORFBPSU5UUyA9IHtcbiAgR0VUX0FMTF9TRVJJRVM6IFwiZ2V0X3Nlcmllc1wiLFxuICBHRVRfQUxMX01PVklFUzogXCJnZXRfdm9kXCIsXG4gIEdFVF9BTExfTElWRV9TVFJFQU1TOiBcImdldF9saXZlX3N0cmVhbXNcIixcbiAgR0VUX1NFUklFU19JTkZPOiBcImdldF9zZXJpZXNfaW5mb1wiLFxuICBHRVRfTU9WSUVfSU5GTzogXCJnZXRfdm9kX2luZm9cIixcbiAgU0VBUkNIOiBcInNlYXJjaFwiLFxufVxuXG5pbnRlcmZhY2UgQXBpUmVzcG9uc2U8VD4ge1xuICBzdGF0dXM6IGJvb2xlYW5cbiAgZGF0YTogVFxuICBlcnJvcj86IHN0cmluZ1xufVxuXG4vLyBEYXRhIFR5cGVzXG5leHBvcnQgaW50ZXJmYWNlIENvbnRlbnRJdGVtIHtcbiAgaWQ6IHN0cmluZ1xuICB0aXRsZTogc3RyaW5nXG4gIGRlc2NyaXB0aW9uOiBzdHJpbmdcbiAgdGh1bWJuYWlsOiBzdHJpbmdcbiAgYmFja2Ryb3A/OiBzdHJpbmdcbiAgdHlwZTogXCJzZXJpZXNcIiB8IFwibW92aWVcIiB8IFwiY2hhbm5lbFwiXG4gIGdlbnJlPzogc3RyaW5nXG4gIHllYXI/OiBzdHJpbmdcbiAgZHVyYXRpb24/OiBzdHJpbmdcbiAgcHJvZ3Jlc3M/OiBudW1iZXJcbiAgZXBpc29kZXM/OiBFcGlzb2RlW11cbiAgaW5mbz86IGFueVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEVwaXNvZGUge1xuICBpZDogc3RyaW5nXG4gIHRpdGxlOiBzdHJpbmdcbiAgZGVzY3JpcHRpb246IHN0cmluZ1xuICB0aHVtYm5haWw/OiBzdHJpbmdcbiAgZHVyYXRpb24/OiBzdHJpbmdcbiAgcHJvZ3Jlc3M/OiBudW1iZXJcbn1cblxuaW50ZXJmYWNlIFNlcmllc1Jlc3BvbnNlIHtcbiAgc2VyaWVzOiB7XG4gICAgW3Nlcmllc0lkOiBzdHJpbmddOiB7XG4gICAgICBuYW1lOiBzdHJpbmdcbiAgICAgIGNvdmVyOiBzdHJpbmdcbiAgICAgIHBsb3Q6IHN0cmluZ1xuICAgICAgZ2VucmU6IHN0cmluZ1xuICAgICAgeWVhcjogc3RyaW5nXG4gICAgICBlcGlzb2RlX2RldGFpbHM6IHtcbiAgICAgICAgW2VwaXNvZGVJZDogc3RyaW5nXToge1xuICAgICAgICAgIHRpdGxlOiBzdHJpbmdcbiAgICAgICAgICBwbG90OiBzdHJpbmdcbiAgICAgICAgICBlcGlzb2RlX251bTogc3RyaW5nXG4gICAgICAgICAgc2Vhc29uX251bTogc3RyaW5nXG4gICAgICAgICAgZHVyYXRpb246IHN0cmluZ1xuICAgICAgICAgIGN1c3RvbV9zaWQ6IHN0cmluZ1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmludGVyZmFjZSBNb3ZpZVJlc3BvbnNlIHtcbiAgdm9kOiB7XG4gICAgW21vdmllSWQ6IHN0cmluZ106IHtcbiAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgY292ZXI6IHN0cmluZ1xuICAgICAgcGxvdDogc3RyaW5nXG4gICAgICBnZW5yZTogc3RyaW5nXG4gICAgICB5ZWFyOiBzdHJpbmdcbiAgICAgIGR1cmF0aW9uOiBzdHJpbmdcbiAgICB9XG4gIH1cbn1cblxuaW50ZXJmYWNlIExpdmVTdHJlYW1SZXNwb25zZSB7XG4gIGxpdmU6IHtcbiAgICBbY2hhbm5lbElkOiBzdHJpbmddOiB7XG4gICAgICBuYW1lOiBzdHJpbmdcbiAgICAgIHN0cmVhbV9pY29uOiBzdHJpbmdcbiAgICAgIGVwZ19jaGFubmVsX2lkOiBzdHJpbmdcbiAgICB9XG4gIH1cbn1cblxuLy8gQVBJIENhbGxzXG5leHBvcnQgY29uc3QgZ2V0QWxsU2VyaWVzID0gYXN5bmMgKCk6IFByb21pc2U8YW55W10+ID0+IHtcbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGlSZXF1ZXN0PGFueT4oXCJnZXRfc2VyaWVzXCIpXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXNwb25zZS5zZXJpZXMgfHwge30pLm1hcCgoW2lkLCBzZXJpZXNdKSA9PiAoeyBpZCwgLi4uc2VyaWVzIH0pKVxufVxuXG5leHBvcnQgY29uc3QgZ2V0QWxsTW92aWVzID0gYXN5bmMgKCk6IFByb21pc2U8YW55W10+ID0+IHtcbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGlSZXF1ZXN0PGFueT4oXCJnZXRfdm9kXCIpXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXNwb25zZS52b2QgfHwge30pLm1hcCgoW2lkLCBtb3ZpZV0pID0+ICh7IGlkLCAuLi5tb3ZpZSB9KSlcbn1cblxuZXhwb3J0IGNvbnN0IGdldEFsbExpdmVTdHJlYW1zID0gYXN5bmMgKCk6IFByb21pc2U8YW55W10+ID0+IHtcbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGlSZXF1ZXN0PGFueT4oXCJnZXRfbGl2ZV9zdHJlYW1zXCIpXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhyZXNwb25zZS5saXZlIHx8IHt9KS5tYXAoKFtpZCwgY2hhbm5lbF0pID0+ICh7IGlkLCAuLi5jaGFubmVsIH0pKVxufVxuXG5leHBvcnQgY29uc3QgZ2V0U2VyaWVzSW5mbyA9IGFzeW5jIChzZXJpZXNJZDogc3RyaW5nKTogUHJvbWlzZTxhbnk+ID0+IHtcbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGlSZXF1ZXN0PGFueT4oQVBJX0VORFBPSU5UUy5HRVRfU0VSSUVTX0lORk8sIHsgc2VyaWVzX2lkOiBzZXJpZXNJZCB9KVxuICByZXR1cm4gcmVzcG9uc2Vcbn1cblxuZXhwb3J0IGNvbnN0IGdldE1vdmllSW5mbyA9IGFzeW5jICh2b2RJZDogc3RyaW5nKTogUHJvbWlzZTxhbnk+ID0+IHtcbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGlSZXF1ZXN0PGFueT4oQVBJX0VORFBPSU5UUy5HRVRfTU9WSUVfSU5GTywgeyB2b2RfaWQ6IHZvZElkIH0pXG4gIHJldHVybiByZXNwb25zZVxufVxuXG5leHBvcnQgY29uc3Qgc2VhcmNoQ29udGVudCA9IGFzeW5jIChxdWVyeTogc3RyaW5nKTogUHJvbWlzZTxDb250ZW50SXRlbVtdPiA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGlSZXF1ZXN0PGFueT4oQVBJX0VORFBPSU5UUy5TRUFSQ0gsIHsgcXVlcnk6IHF1ZXJ5IH0pXG5cbiAgICBpZiAoIXJlc3BvbnNlIHx8ICFyZXNwb25zZS5kYXRhKSB7XG4gICAgICByZXR1cm4gW11cbiAgICB9XG5cbiAgICBjb25zdCBzZXJpZXNSZXN1bHRzID0gT2JqZWN0LmVudHJpZXMocmVzcG9uc2UuZGF0YS5zZXJpZXMgfHwge30pLm1hcCgoW2lkLCBzZXJpZXNdKSA9PlxuICAgICAgbWFwU2VyaWVzVG9Db250ZW50KHsgaWQsIC4uLnNlcmllcyB9KSxcbiAgICApXG4gICAgY29uc3QgbW92aWVSZXN1bHRzID0gT2JqZWN0LmVudHJpZXMocmVzcG9uc2UuZGF0YS52b2QgfHwge30pLm1hcCgoW2lkLCBtb3ZpZV0pID0+XG4gICAgICBtYXBNb3ZpZVRvQ29udGVudCh7IGlkLCAuLi5tb3ZpZSB9KSxcbiAgICApXG4gICAgY29uc3QgY2hhbm5lbFJlc3VsdHMgPSBPYmplY3QuZW50cmllcyhyZXNwb25zZS5kYXRhLmxpdmUgfHwge30pLm1hcCgoW2lkLCBjaGFubmVsXSkgPT5cbiAgICAgIG1hcENoYW5uZWxUb0NvbnRlbnQoeyBpZCwgLi4uY2hhbm5lbCB9KSxcbiAgICApXG5cbiAgICByZXR1cm4gWy4uLnNlcmllc1Jlc3VsdHMsIC4uLm1vdmllUmVzdWx0cywgLi4uY2hhbm5lbFJlc3VsdHNdXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihcIlNlYXJjaCBmYWlsZWQ6XCIsIGVycm9yKVxuICAgIHJldHVybiBbXVxuICB9XG59XG5cbi8vIERhdGEgTWFwcGluZyBGdW5jdGlvbnNcbmV4cG9ydCBjb25zdCBtYXBTZXJpZXNUb0NvbnRlbnQgPSAoc2VyaWVzOiBhbnkpOiBDb250ZW50SXRlbSA9PiAoe1xuICBpZDogc2VyaWVzLmlkLFxuICB0aXRsZTogc2VyaWVzLm5hbWUsXG4gIGRlc2NyaXB0aW9uOiBzZXJpZXMucGxvdCxcbiAgdGh1bWJuYWlsOiBzZXJpZXMuY292ZXIsXG4gIHR5cGU6IFwic2VyaWVzXCIsXG4gIGdlbnJlOiBzZXJpZXMuZ2VucmUsXG4gIHllYXI6IHNlcmllcy55ZWFyLFxufSlcblxuZXhwb3J0IGNvbnN0IG1hcE1vdmllVG9Db250ZW50ID0gKG1vdmllOiBhbnkpOiBDb250ZW50SXRlbSA9PiAoe1xuICBpZDogbW92aWUuaWQsXG4gIHRpdGxlOiBtb3ZpZS5uYW1lLFxuICBkZXNjcmlwdGlvbjogbW92aWUucGxvdCxcbiAgdGh1bWJuYWlsOiBtb3ZpZS5jb3ZlcixcbiAgdHlwZTogXCJtb3ZpZVwiLFxuICBnZW5yZTogbW92aWUuZ2VucmUsXG4gIHllYXI6IG1vdmllLnllYXIsXG4gIGR1cmF0aW9uOiBtb3ZpZS5kdXJhdGlvbixcbn0pXG5cbmV4cG9ydCBjb25zdCBtYXBDaGFubmVsVG9Db250ZW50ID0gKGNoYW5uZWw6IGFueSk6IENvbnRlbnRJdGVtID0+ICh7XG4gIGlkOiBjaGFubmVsLmlkLFxuICB0aXRsZTogY2hhbm5lbC5uYW1lLFxuICBkZXNjcmlwdGlvbjogXCJcIixcbiAgdGh1bWJuYWlsOiBjaGFubmVsLnN0cmVhbV9pY29uLFxuICB0eXBlOiBcImNoYW5uZWxcIixcbn0pXG5cbmV4cG9ydCBjb25zdCBtYXBTZXJpZXNEZXRhaWxzVG9Db250ZW50ID0gKHNlcmllc0RldGFpbHM6IGFueSk6IENvbnRlbnRJdGVtID0+IHtcbiAgY29uc3Qgc2VyaWVzID0gc2VyaWVzRGV0YWlscy5pbmZvXG4gIGNvbnN0IGVwaXNvZGVzOiBFcGlzb2RlW10gPSBPYmplY3QuZW50cmllcyhzZXJpZXNEZXRhaWxzLmVwaXNvZGVzIHx8IHt9KS5tYXAoXG4gICAgKFtlcGlzb2RlSWQsIGVwaXNvZGVdOiBbc3RyaW5nLCBhbnldKSA9PiAoe1xuICAgICAgaWQ6IGVwaXNvZGVJZCxcbiAgICAgIHRpdGxlOiBlcGlzb2RlLnRpdGxlLFxuICAgICAgZGVzY3JpcHRpb246IGVwaXNvZGUucGxvdCxcbiAgICAgIGR1cmF0aW9uOiBlcGlzb2RlLmR1cmF0aW9uLFxuICAgIH0pLFxuICApXG5cbiAgcmV0dXJuIHtcbiAgICBpZDogc2VyaWVzLmlkLFxuICAgIHRpdGxlOiBzZXJpZXMubmFtZSxcbiAgICBkZXNjcmlwdGlvbjogc2VyaWVzLnBsb3QsXG4gICAgdGh1bWJuYWlsOiBzZXJpZXMuY292ZXIsXG4gICAgdHlwZTogXCJzZXJpZXNcIixcbiAgICBnZW5yZTogc2VyaWVzLmdlbnJlLFxuICAgIHllYXI6IHNlcmllcy55ZWFyLFxuICAgIGVwaXNvZGVzOiBlcGlzb2RlcyxcbiAgfVxufVxuXG4vLyBMb2NhbCBTdG9yYWdlIEZ1bmN0aW9uc1xuY29uc3QgUFJPR1JFU1NfS0VZID0gXCJjb250ZW50UHJvZ3Jlc3NcIlxuXG5leHBvcnQgY29uc3Qgc2F2ZUNvbnRlbnRQcm9ncmVzcyA9IChjb250ZW50SWQ6IHN0cmluZywgY3VycmVudFRpbWU6IG51bWJlciwgZHVyYXRpb246IG51bWJlciwgZXBpc29kZUlkPzogc3RyaW5nKSA9PiB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSByZXR1cm5cblxuICB0cnkge1xuICAgIGNvbnN0IHByb2dyZXNzRGF0YSA9IEpTT04ucGFyc2UobG9jYWxTdG9yYWdlLmdldEl0ZW0oUFJPR1JFU1NfS0VZKSB8fCBcInt9XCIpXG4gICAgcHJvZ3Jlc3NEYXRhW2NvbnRlbnRJZCArIChlcGlzb2RlSWQgPyBgXyR7ZXBpc29kZUlkfWAgOiBcIlwiKV0gPSB7IGN1cnJlbnRUaW1lLCBkdXJhdGlvbiB9XG4gICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oUFJPR1JFU1NfS0VZLCBKU09OLnN0cmluZ2lmeShwcm9ncmVzc0RhdGEpKVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gc2F2ZSBjb250ZW50IHByb2dyZXNzOlwiLCBlcnJvcilcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgZ2V0Q29udGVudEN1cnJlbnRUaW1lID0gKGNvbnRlbnRJZDogc3RyaW5nLCBlcGlzb2RlSWQ/OiBzdHJpbmcpOiBudW1iZXIgfCBudWxsID0+IHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHJldHVybiBudWxsXG5cbiAgdHJ5IHtcbiAgICBjb25zdCBwcm9ncmVzc0RhdGEgPSBKU09OLnBhcnNlKGxvY2FsU3RvcmFnZS5nZXRJdGVtKFBST0dSRVNTX0tFWSkgfHwgXCJ7fVwiKVxuICAgIGNvbnN0IHByb2dyZXNzID0gcHJvZ3Jlc3NEYXRhW2NvbnRlbnRJZCArIChlcGlzb2RlSWQgPyBgXyR7ZXBpc29kZUlkfWAgOiBcIlwiKV1cbiAgICByZXR1cm4gcHJvZ3Jlc3MgPyBwcm9ncmVzcy5jdXJyZW50VGltZSA6IG51bGxcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIGdldCBjb250ZW50IHByb2dyZXNzOlwiLCBlcnJvcilcbiAgICByZXR1cm4gbnVsbFxuICB9XG59XG5cbi8vIFRlc3QgQ29ubmVjdGlvblxuZXhwb3J0IGNvbnN0IHRlc3RDb25uZWN0aW9uID0gYXN5bmMgKCk6IFByb21pc2U8Ym9vbGVhbj4gPT4ge1xuICB0cnkge1xuICAgIC8vIEF0dGVtcHQgdG8gZmV0Y2ggc2VyaWVzIChhIGJhc2ljIEFQSSBjYWxsKVxuICAgIGF3YWl0IGdldEFsbFNlcmllcygpXG4gICAgcmV0dXJuIHRydWVcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiQ29ubmVjdGlvbiB0ZXN0IGZhaWxlZDpcIiwgZXJyb3IpXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuLy8gRXJyb3IgTWVzc2FnZSBIZWxwZXJcbmV4cG9ydCBjb25zdCBnZXRFcnJvck1lc3NhZ2UgPSAoZXJyb3I6IGFueSk6IHN0cmluZyA9PiB7XG4gIGlmIChlcnJvciBpbnN0YW5jZW9mIEF1dGhlbnRpY2F0aW9uRXJyb3IpIHtcbiAgICByZXR1cm4gXCJGYWxoYSBuYSBhdXRlbnRpY2HDp8Ojby4gVmVyaWZpcXVlIHN1YXMgY3JlZGVuY2lhaXMuXCJcbiAgfSBlbHNlIGlmIChlcnJvciBpbnN0YW5jZW9mIE5vdEZvdW5kRXJyb3IpIHtcbiAgICByZXR1cm4gXCJSZWN1cnNvIG7Do28gZW5jb250cmFkby5cIlxuICB9IGVsc2UgaWYgKGVycm9yIGluc3RhbmNlb2YgQXBpRXJyb3IpIHtcbiAgICByZXR1cm4gYEVycm8gbmEgQVBJOiAke2Vycm9yLm1lc3NhZ2V9YFxuICB9IGVsc2UgaWYgKGVycm9yIGluc3RhbmNlb2YgTmV0d29ya0Vycm9yKSB7XG4gICAgcmV0dXJuIFwiRXJybyBkZSByZWRlLiBWZXJpZmlxdWUgc3VhIGNvbmV4w6NvIGNvbSBhIGludGVybmV0LlwiXG4gIH0gZWxzZSBpZiAoZXJyb3IgaW5zdGFuY2VvZiBUeXBlRXJyb3IgJiYgZXJyb3IubWVzc2FnZS5pbmNsdWRlcyhcIkZhaWxlZCB0byBmZXRjaFwiKSkge1xuICAgIHJldHVybiBcIkVycm8gYW8gY29uZWN0YXIgYW8gc2Vydmlkb3IuIFZlcmlmaXF1ZSBhIFVSTCBlIHN1YSBjb25leMOjby5cIlxuICB9IGVsc2Uge1xuICAgIHJldHVybiBcIk9jb3JyZXUgdW0gZXJybyBpbmVzcGVyYWRvLlwiXG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJBdXRoZW50aWNhdGlvbkVycm9yIiwiRXJyb3IiLCJjb25zdHJ1Y3RvciIsIm1lc3NhZ2UiLCJuYW1lIiwiTm90Rm91bmRFcnJvciIsIkFwaUVycm9yIiwic3RhdHVzQ29kZSIsIk5ldHdvcmtFcnJvciIsImdldENyZWRlbnRpYWxzIiwic3RvcmVkQ29uZmlnIiwibG9jYWxTdG9yYWdlIiwiZ2V0SXRlbSIsImNyZWRlbnRpYWxzIiwiSlNPTiIsInBhcnNlIiwiZm9yY2VIdHRwcyIsImFwaVVybCIsInRvTG93ZXJDYXNlIiwic3RhcnRzV2l0aCIsInJlcGxhY2UiLCJlcnJvciIsImNvbnNvbGUiLCJhcGlSZXF1ZXN0IiwiZW5kcG9pbnQiLCJwYXJhbXMiLCJyZXRyaWVzIiwidXNlcm5hbWUiLCJwYXNzd29yZCIsInVybCIsIlVSTCIsInF1ZXJ5UGFyYW1zIiwiVVJMU2VhcmNoUGFyYW1zIiwiYWN0aW9uIiwiZnVsbFVybCIsInRvU3RyaW5nIiwicHJveHlVcmwiLCJyZXNwb25zZSIsImZldGNoIiwibWV0aG9kIiwibW9kZSIsImhlYWRlcnMiLCJzaWduYWwiLCJBYm9ydFNpZ25hbCIsInRpbWVvdXQiLCJsb2ciLCJvayIsInN0YXR1cyIsInN0YXR1c1RleHQiLCJkYXRhIiwianNvbiIsIndhcm4iLCJUeXBlRXJyb3IiLCJlcnJvck1lc3NhZ2UiLCJpbmNsdWRlcyIsIlByb21pc2UiLCJyZXNvbHZlIiwic2V0VGltZW91dCIsImdldFN0cmVhbVVybCIsInN0cmVhbUlkIiwic3RyZWFtVHlwZSIsImVwaXNvZGVJZCIsImJhc2VVcmwiLCJBUElfRU5EUE9JTlRTIiwiR0VUX0FMTF9TRVJJRVMiLCJHRVRfQUxMX01PVklFUyIsIkdFVF9BTExfTElWRV9TVFJFQU1TIiwiR0VUX1NFUklFU19JTkZPIiwiR0VUX01PVklFX0lORk8iLCJTRUFSQ0giLCJnZXRBbGxTZXJpZXMiLCJPYmplY3QiLCJlbnRyaWVzIiwic2VyaWVzIiwibWFwIiwiaWQiLCJnZXRBbGxNb3ZpZXMiLCJ2b2QiLCJtb3ZpZSIsImdldEFsbExpdmVTdHJlYW1zIiwibGl2ZSIsImNoYW5uZWwiLCJnZXRTZXJpZXNJbmZvIiwic2VyaWVzSWQiLCJzZXJpZXNfaWQiLCJnZXRNb3ZpZUluZm8iLCJ2b2RJZCIsInZvZF9pZCIsInNlYXJjaENvbnRlbnQiLCJxdWVyeSIsInNlcmllc1Jlc3VsdHMiLCJtYXBTZXJpZXNUb0NvbnRlbnQiLCJtb3ZpZVJlc3VsdHMiLCJtYXBNb3ZpZVRvQ29udGVudCIsImNoYW5uZWxSZXN1bHRzIiwibWFwQ2hhbm5lbFRvQ29udGVudCIsInRpdGxlIiwiZGVzY3JpcHRpb24iLCJwbG90IiwidGh1bWJuYWlsIiwiY292ZXIiLCJ0eXBlIiwiZ2VucmUiLCJ5ZWFyIiwiZHVyYXRpb24iLCJzdHJlYW1faWNvbiIsIm1hcFNlcmllc0RldGFpbHNUb0NvbnRlbnQiLCJzZXJpZXNEZXRhaWxzIiwiaW5mbyIsImVwaXNvZGVzIiwiZXBpc29kZSIsIlBST0dSRVNTX0tFWSIsInNhdmVDb250ZW50UHJvZ3Jlc3MiLCJjb250ZW50SWQiLCJjdXJyZW50VGltZSIsInByb2dyZXNzRGF0YSIsInNldEl0ZW0iLCJzdHJpbmdpZnkiLCJnZXRDb250ZW50Q3VycmVudFRpbWUiLCJwcm9ncmVzcyIsInRlc3RDb25uZWN0aW9uIiwiZ2V0RXJyb3JNZXNzYWdlIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/api-service.ts\n"));

/***/ })

});