"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/api-service.ts":
/*!****************************!*\
  !*** ./lib/api-service.ts ***!
  \****************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ApiError: () => (/* binding */ ApiError),\n/* harmony export */   AuthenticationError: () => (/* binding */ AuthenticationError),\n/* harmony export */   NetworkError: () => (/* binding */ NetworkError),\n/* harmony export */   NotFoundError: () => (/* binding */ NotFoundError),\n/* harmony export */   getAllLiveStreams: () => (/* binding */ getAllLiveStreams),\n/* harmony export */   getAllMovies: () => (/* binding */ getAllMovies),\n/* harmony export */   getAllSeries: () => (/* binding */ getAllSeries),\n/* harmony export */   getContentCurrentTime: () => (/* binding */ getContentCurrentTime),\n/* harmony export */   getCredentials: () => (/* binding */ getCredentials),\n/* harmony export */   getErrorMessage: () => (/* binding */ getErrorMessage),\n/* harmony export */   getMovieInfo: () => (/* binding */ getMovieInfo),\n/* harmony export */   getSeriesInfo: () => (/* binding */ getSeriesInfo),\n/* harmony export */   getStreamUrl: () => (/* binding */ getStreamUrl),\n/* harmony export */   mapChannelToContent: () => (/* binding */ mapChannelToContent),\n/* harmony export */   mapMovieToContent: () => (/* binding */ mapMovieToContent),\n/* harmony export */   mapSeriesDetailsToContent: () => (/* binding */ mapSeriesDetailsToContent),\n/* harmony export */   mapSeriesToContent: () => (/* binding */ mapSeriesToContent),\n/* harmony export */   saveContentProgress: () => (/* binding */ saveContentProgress),\n/* harmony export */   searchContent: () => (/* binding */ searchContent),\n/* harmony export */   testConnection: () => (/* binding */ testConnection)\n/* harmony export */ });\n// Update the ApiCredentials interface to include forceHttps\n// Custom error classes\nclass AuthenticationError extends Error {\n    constructor(message = \"Authentication failed\"){\n        super(message);\n        this.name = \"AuthenticationError\";\n    }\n}\nclass NotFoundError extends Error {\n    constructor(message = \"Resource not found\"){\n        super(message);\n        this.name = \"NotFoundError\";\n    }\n}\nclass ApiError extends Error {\n    constructor(message = \"API error\", statusCode){\n        super(message);\n        this.name = \"ApiError\";\n        this.statusCode = statusCode;\n    }\n}\nclass NetworkError extends Error {\n    constructor(message = \"Network error\"){\n        super(message);\n        this.name = \"NetworkError\";\n    }\n}\n// Update the getCredentials function to handle the forceHttps option\nconst getCredentials = ()=>{\n    if (false) {}\n    const storedConfig = localStorage.getItem(\"streamConfig\");\n    if (!storedConfig) return null;\n    try {\n        const credentials = JSON.parse(storedConfig);\n        // If forceHttps is enabled, ensure the URL uses HTTPS\n        if (credentials.forceHttps && credentials.apiUrl.toLowerCase().startsWith(\"http:\")) {\n            credentials.apiUrl = credentials.apiUrl.replace(/^http:/i, \"https:\");\n        }\n        return credentials;\n    } catch (error) {\n        console.error(\"Failed to parse stored credentials:\", error);\n        return null;\n    }\n};\n// Update the apiRequest function to better handle mixed content errors\nasync function apiRequest(endpoint) {\n    let params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, retries = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 2;\n    const credentials = getCredentials();\n    if (!credentials) {\n        throw new AuthenticationError(\"Credenciais não encontradas. Configure o aplicativo primeiro.\");\n    }\n    const { apiUrl, username, password } = credentials;\n    // Build URL with credentials and params\n    let url;\n    try {\n        url = new URL(apiUrl);\n    } catch (error) {\n        throw new Error(\"URL inv\\xe1lida: \".concat(apiUrl, \". Verifique a configura\\xe7\\xe3o.\"));\n    }\n    // Check for potential mixed content issues\n    if ( true && window.location.protocol === \"https:\" && url.protocol === \"http:\") {\n        console.warn(\"Potential mixed content issue: trying to load HTTP content in an HTTPS page\");\n    }\n    // Add authentication params and action\n    const queryParams = new URLSearchParams({\n        username,\n        password,\n        action: endpoint,\n        ...params\n    });\n    let fullUrl = \"\".concat(url.toString(), \"?\").concat(queryParams.toString());\n    try {\n        const response = await fetch(fullUrl, {\n            method: \"GET\",\n            mode: \"cors\",\n            credentials: \"omit\",\n            headers: {\n                \"accept\": \"application/json\",\n                \"accept-language\": \"pt-BR,pt;q=0.9,en-US;q=0.8,en;q=0.7\"\n            },\n            signal: AbortSignal.timeout(30000)\n        });\n        // Clone the response for debugging\n        const responseClone = response.clone();\n        const data = await responseClone.json();\n        console.log(\"API Response Data:\", data);\n        // Handle different HTTP status codes\n        if (!response.ok) {\n            if (response.status === 401 || response.status === 403) {\n                throw new AuthenticationError();\n            } else if (response.status === 404) {\n                throw new NotFoundError();\n            } else {\n                throw new ApiError(\"Erro na API: \".concat(response.statusText), response.status);\n            }\n        }\n        // Parse JSON response\n        try {\n            const data = await response.json() // O await agora deve funcionar corretamente\n            ;\n            // Some APIs return error information in the response body\n            if (data && data.error) {\n                throw new ApiError(\"Erro na API: \".concat(data.error));\n            }\n            return data;\n        } catch (error) {\n            throw new ApiError(\"Erro ao processar resposta da API. Formato inválido.\");\n        }\n    } catch (error) {\n        // Handle timeout errors\n        if (error.name === \"AbortError\") {\n            console.error(\"A requisição demorou muito e foi abortada.\");\n            throw new NetworkError(\"A requisição excedeu o tempo limite. Tente novamente.\");\n        }\n        // Check specifically for mixed content errors\n        if (error instanceof TypeError) {\n            const errorMessage = error.message.toLowerCase();\n            if (errorMessage.includes(\"mixed content\") || errorMessage.includes(\"blocked\") && errorMessage.includes(\"insecure\")) {\n                throw new NetworkError(\"Erro de conteúdo misto: seu navegador bloqueou a requisição HTTP em um site HTTPS. \" + \"Tente ativar 'Forçar HTTPS' nas configurações ou use um servidor com HTTPS.\");\n            }\n            // Handle network errors and implement retry logic\n            if (errorMessage.includes(\"fetch\")) {\n                // Network error\n                if (retries > 0) {\n                    console.log(\"Retry attempt (\".concat(retries, \" remaining) for \").concat(fullUrl));\n                    // Exponential backoff: wait longer between retries\n                    await new Promise((resolve)=>setTimeout(resolve, (3 - retries) * 1000));\n                    return apiRequest(endpoint, params, retries - 1);\n                }\n                throw new NetworkError();\n            }\n        }\n        // Re-throw other errors\n        throw error;\n    }\n}\n// Update the getStreamUrl function to handle HTTPS\nconst getStreamUrl = (streamId, streamType, episodeId)=>{\n    const credentials = getCredentials();\n    if (!credentials) {\n        throw new AuthenticationError(\"Credenciais não encontradas. Configure o aplicativo primeiro.\");\n    }\n    const { apiUrl, username, password, forceHttps } = credentials;\n    let baseUrl = apiUrl.replace(\"player_api.php\", \"\");\n    // If forceHttps is enabled, ensure the URL uses HTTPS\n    if (forceHttps && baseUrl.toLowerCase().startsWith(\"http:\")) {\n        baseUrl = baseUrl.replace(/^http:/i, \"https:\");\n    }\n    if (streamType === \"live\") {\n        return \"\".concat(baseUrl, \"live/\").concat(username, \"/\").concat(password, \"/\").concat(streamId, \".ts\");\n    } else if (streamType === \"movie\") {\n        return \"\".concat(baseUrl, \"movie/\").concat(username, \"/\").concat(password, \"/\").concat(streamId, \".mp4\");\n    } else if (streamType === \"series\") {\n        if (!episodeId) {\n            throw new Error(\"ID do episódio é obrigatório para séries\");\n        }\n        return \"\".concat(baseUrl, \"series/\").concat(username, \"/\").concat(password, \"/\").concat(streamId, \"/\").concat(episodeId, \".mp4\");\n    }\n    throw new Error(\"Tipo de stream inválido\");\n};\n// API Endpoints and Data Mapping\nconst API_ENDPOINTS = {\n    GET_ALL_SERIES: \"get_series\",\n    GET_ALL_MOVIES: \"get_vod\",\n    GET_ALL_LIVE_STREAMS: \"get_live_streams\",\n    GET_SERIES_INFO: \"get_series_info\",\n    GET_MOVIE_INFO: \"get_vod_info\",\n    SEARCH: \"search\"\n};\n// API Calls\nconst getAllSeries = async function() {\n    let page = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1, pageSize = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 30;\n    const response = await apiRequest(\"get_series\");\n    let items = [];\n    if (Array.isArray(response)) {\n        items = response;\n    } else if (response && typeof response === \"object\") {\n        items = Object.values(response);\n    }\n    const start = (page - 1) * pageSize;\n    const end = start + pageSize;\n    return items.slice(start, end).map(mapSeriesToContent);\n};\nconst getAllMovies = async ()=>{\n    const response = await apiRequest(\"get_vod\");\n    let items = [];\n    if (Array.isArray(response)) {\n        items = response;\n    } else if (response && typeof response === \"object\" && response.vod) {\n        items = Object.values(response.vod);\n    }\n    return items.map(mapMovieToContent);\n};\nconst getAllLiveStreams = async ()=>{\n    const response = await apiRequest(\"get_live_streams\");\n    let items = [];\n    if (Array.isArray(response)) {\n        items = response;\n    } else if (response && typeof response === \"object\" && response.live) {\n        items = Object.values(response.live);\n    }\n    return items.map(mapChannelToContent);\n};\nconst getSeriesInfo = async (seriesId)=>{\n    const response = await apiRequest(API_ENDPOINTS.GET_SERIES_INFO, {\n        series_id: seriesId\n    });\n    return response;\n};\nconst getMovieInfo = async (vodId)=>{\n    const response = await apiRequest(API_ENDPOINTS.GET_MOVIE_INFO, {\n        vod_id: vodId\n    });\n    return response;\n};\nconst searchContent = async (query)=>{\n    try {\n        const response = await apiRequest(API_ENDPOINTS.SEARCH, {\n            query: query\n        });\n        if (!response || !response.data) {\n            return [];\n        }\n        const seriesResults = Array.isArray(response.data.series) ? response.data.series.map(mapSeriesToContent) : Object.values(response.data.series || {}).map(mapSeriesToContent);\n        const movieResults = Array.isArray(response.data.vod) ? response.data.vod.map(mapMovieToContent) : Object.values(response.data.vod || {}).map(mapMovieToContent);\n        const channelResults = Array.isArray(response.data.live) ? response.data.live.map(mapChannelToContent) : Object.values(response.data.live || {}).map(mapChannelToContent);\n        return [\n            ...seriesResults,\n            ...movieResults,\n            ...channelResults\n        ];\n    } catch (error) {\n        console.error(\"Search failed:\", error);\n        return [];\n    }\n};\n// Data Mapping Functions\nconst mapSeriesToContent = (series)=>{\n    var _series_series_id, _series_name, _series_plot, _series_cover, _series_genre, _series_year;\n    return {\n        id: String((_series_series_id = series.series_id) !== null && _series_series_id !== void 0 ? _series_series_id : series.id),\n        title: (_series_name = series.name) !== null && _series_name !== void 0 ? _series_name : series.title,\n        description: (_series_plot = series.plot) !== null && _series_plot !== void 0 ? _series_plot : \"\",\n        thumbnail: (_series_cover = series.cover) !== null && _series_cover !== void 0 ? _series_cover : \"\",\n        type: \"series\",\n        genre: (_series_genre = series.genre) !== null && _series_genre !== void 0 ? _series_genre : \"\",\n        year: (_series_year = series.year) !== null && _series_year !== void 0 ? _series_year : \"\",\n        backdrop: Array.isArray(series.backdrop_path) ? series.backdrop_path[0] : undefined,\n        info: series\n    };\n};\nconst mapMovieToContent = (movie)=>({\n        id: movie.id,\n        title: movie.name,\n        description: movie.plot,\n        thumbnail: movie.cover,\n        type: \"movie\",\n        genre: movie.genre,\n        year: movie.year,\n        duration: movie.duration\n    });\nconst mapChannelToContent = (channel)=>({\n        id: channel.id,\n        title: channel.name,\n        description: \"\",\n        thumbnail: channel.stream_icon,\n        type: \"channel\"\n    });\nconst mapSeriesDetailsToContent = (seriesDetails)=>{\n    const series = seriesDetails.info;\n    const episodes = [];\n    // Processar episódios de todas as temporadas\n    Object.entries(seriesDetails.episodes || {}).forEach((param)=>{\n        let [seasonNum, seasonEpisodes] = param;\n        seasonEpisodes.forEach((episode)=>{\n            var _episode_info, _episode_info1, _episode_info2, _episode_info3;\n            episodes.push({\n                id: episode.id,\n                title: episode.title,\n                description: ((_episode_info = episode.info) === null || _episode_info === void 0 ? void 0 : _episode_info.plot) || \"\",\n                thumbnail: ((_episode_info1 = episode.info) === null || _episode_info1 === void 0 ? void 0 : _episode_info1.movie_image) || ((_episode_info2 = episode.info) === null || _episode_info2 === void 0 ? void 0 : _episode_info2.cover_big) || series.cover,\n                duration: ((_episode_info3 = episode.info) === null || _episode_info3 === void 0 ? void 0 : _episode_info3.duration) || \"\",\n                season: episode.season,\n                episodeNumber: episode.episode_num\n            });\n        });\n    });\n    // Ordenar episódios por temporada e número do episódio\n    episodes.sort((a, b)=>{\n        if (a.season !== b.season) {\n            return a.season - b.season;\n        }\n        return parseInt(a.episodeNumber) - parseInt(b.episodeNumber);\n    });\n    return {\n        id: series.id,\n        title: series.name || series.title,\n        description: series.plot,\n        thumbnail: series.cover,\n        type: \"series\",\n        genre: series.genre,\n        year: series.year,\n        backdrop: Array.isArray(series.backdrop_path) ? series.backdrop_path[0] : undefined,\n        episodes: episodes,\n        info: {\n            ...series,\n            seasons: seriesDetails.seasons\n        }\n    };\n};\n// Local Storage Functions\nconst PROGRESS_KEY = \"contentProgress\";\nconst saveContentProgress = (contentId, currentTime, duration, episodeId)=>{\n    if (false) {}\n    try {\n        const progressData = JSON.parse(localStorage.getItem(PROGRESS_KEY) || \"{}\");\n        progressData[contentId + (episodeId ? \"_\".concat(episodeId) : \"\")] = {\n            currentTime,\n            duration\n        };\n        localStorage.setItem(PROGRESS_KEY, JSON.stringify(progressData));\n    } catch (error) {\n        console.error(\"Failed to save content progress:\", error);\n    }\n};\nconst getContentCurrentTime = (contentId, episodeId)=>{\n    if (false) {}\n    try {\n        const progressData = JSON.parse(localStorage.getItem(PROGRESS_KEY) || \"{}\");\n        const progress = progressData[contentId + (episodeId ? \"_\".concat(episodeId) : \"\")];\n        return progress ? progress.currentTime : null;\n    } catch (error) {\n        console.error(\"Failed to get content progress:\", error);\n        return null;\n    }\n};\n// Test Connection\nconst testConnection = async ()=>{\n    try {\n        // Attempt to fetch series (a basic API call)\n        await getAllSeries(1, 1);\n        return true;\n    } catch (error) {\n        console.error(\"Connection test failed:\", error);\n        return false;\n    }\n};\n// Error Message Helper\nconst getErrorMessage = (error)=>{\n    if (error instanceof AuthenticationError) {\n        return \"Falha na autenticação. Verifique suas credenciais.\";\n    } else if (error instanceof NotFoundError) {\n        return \"Recurso não encontrado.\";\n    } else if (error instanceof ApiError) {\n        return \"Erro na API: \".concat(error.message);\n    } else if (error instanceof NetworkError) {\n        return \"Erro de rede. Verifique sua conexão com a internet.\";\n    } else if (error instanceof TypeError && error.message.includes(\"Failed to fetch\")) {\n        return \"Erro ao conectar ao servidor. Verifique a URL e sua conexão.\";\n    } else {\n        return \"Ocorreu um erro inesperado.\";\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QWlCYixjQUFjO1FBQ3hDLE9BQU87SUFDVCxPQUFPLElBQUlhLGlCQUFpQm1DLGFBQWFuQyxNQUFNbEIsT0FBTyxDQUFDdUQsUUFBUSxDQUFDLG9CQUFvQjtRQUNsRixPQUFPO0lBQ1QsT0FBTztRQUNMLE9BQU87SUFDVDtBQUNGLEVBQUMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9oZWl0b3IuY2FuZGlkby9Eb2N1bWVudHMvaXB0di9pcHR2LWFwcC9saWIvYXBpLXNlcnZpY2UudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gVXBkYXRlIHRoZSBBcGlDcmVkZW50aWFscyBpbnRlcmZhY2UgdG8gaW5jbHVkZSBmb3JjZUh0dHBzXG5leHBvcnQgaW50ZXJmYWNlIEFwaUNyZWRlbnRpYWxzIHtcbiAgYXBpVXJsOiBzdHJpbmdcbiAgdXNlcm5hbWU6IHN0cmluZ1xuICBwYXNzd29yZDogc3RyaW5nXG4gIGZvcmNlSHR0cHM/OiBib29sZWFuXG59XG5cbi8vIEN1c3RvbSBlcnJvciBjbGFzc2VzXG5leHBvcnQgY2xhc3MgQXV0aGVudGljYXRpb25FcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSA9IFwiQXV0aGVudGljYXRpb24gZmFpbGVkXCIpIHtcbiAgICBzdXBlcihtZXNzYWdlKVxuICAgIHRoaXMubmFtZSA9IFwiQXV0aGVudGljYXRpb25FcnJvclwiXG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIE5vdEZvdW5kRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UgPSBcIlJlc291cmNlIG5vdCBmb3VuZFwiKSB7XG4gICAgc3VwZXIobWVzc2FnZSlcbiAgICB0aGlzLm5hbWUgPSBcIk5vdEZvdW5kRXJyb3JcIlxuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBBcGlFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgcHVibGljIHN0YXR1c0NvZGU6IG51bWJlciB8IHVuZGVmaW5lZFxuXG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UgPSBcIkFQSSBlcnJvclwiLCBzdGF0dXNDb2RlPzogbnVtYmVyKSB7XG4gICAgc3VwZXIobWVzc2FnZSlcbiAgICB0aGlzLm5hbWUgPSBcIkFwaUVycm9yXCJcbiAgICB0aGlzLnN0YXR1c0NvZGUgPSBzdGF0dXNDb2RlXG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIE5ldHdvcmtFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSA9IFwiTmV0d29yayBlcnJvclwiKSB7XG4gICAgc3VwZXIobWVzc2FnZSlcbiAgICB0aGlzLm5hbWUgPSBcIk5ldHdvcmtFcnJvclwiXG4gIH1cbn1cblxuLy8gVXBkYXRlIHRoZSBnZXRDcmVkZW50aWFscyBmdW5jdGlvbiB0byBoYW5kbGUgdGhlIGZvcmNlSHR0cHMgb3B0aW9uXG5leHBvcnQgY29uc3QgZ2V0Q3JlZGVudGlhbHMgPSAoKTogQXBpQ3JlZGVudGlhbHMgfCBudWxsID0+IHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHJldHVybiBudWxsXG5cbiAgY29uc3Qgc3RvcmVkQ29uZmlnID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oXCJzdHJlYW1Db25maWdcIilcbiAgaWYgKCFzdG9yZWRDb25maWcpIHJldHVybiBudWxsXG5cbiAgdHJ5IHtcbiAgICBjb25zdCBjcmVkZW50aWFscyA9IEpTT04ucGFyc2Uoc3RvcmVkQ29uZmlnKSBhcyBBcGlDcmVkZW50aWFsc1xuXG4gICAgLy8gSWYgZm9yY2VIdHRwcyBpcyBlbmFibGVkLCBlbnN1cmUgdGhlIFVSTCB1c2VzIEhUVFBTXG4gICAgaWYgKGNyZWRlbnRpYWxzLmZvcmNlSHR0cHMgJiYgY3JlZGVudGlhbHMuYXBpVXJsLnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aChcImh0dHA6XCIpKSB7XG4gICAgICBjcmVkZW50aWFscy5hcGlVcmwgPSBjcmVkZW50aWFscy5hcGlVcmwucmVwbGFjZSgvXmh0dHA6L2ksIFwiaHR0cHM6XCIpXG4gICAgfVxuXG4gICAgcmV0dXJuIGNyZWRlbnRpYWxzXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBwYXJzZSBzdG9yZWQgY3JlZGVudGlhbHM6XCIsIGVycm9yKVxuICAgIHJldHVybiBudWxsXG4gIH1cbn1cblxuLy8gVXBkYXRlIHRoZSBhcGlSZXF1ZXN0IGZ1bmN0aW9uIHRvIGJldHRlciBoYW5kbGUgbWl4ZWQgY29udGVudCBlcnJvcnNcbmFzeW5jIGZ1bmN0aW9uIGFwaVJlcXVlc3Q8VD4oZW5kcG9pbnQ6IHN0cmluZywgcGFyYW1zOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge30sIHJldHJpZXMgPSAyKTogUHJvbWlzZTxUPiB7XG4gIGNvbnN0IGNyZWRlbnRpYWxzID0gZ2V0Q3JlZGVudGlhbHMoKVxuICBpZiAoIWNyZWRlbnRpYWxzKSB7XG4gICAgdGhyb3cgbmV3IEF1dGhlbnRpY2F0aW9uRXJyb3IoXCJDcmVkZW5jaWFpcyBuw6NvIGVuY29udHJhZGFzLiBDb25maWd1cmUgbyBhcGxpY2F0aXZvIHByaW1laXJvLlwiKVxuICB9XG5cbiAgY29uc3QgeyBhcGlVcmwsIHVzZXJuYW1lLCBwYXNzd29yZCB9ID0gY3JlZGVudGlhbHNcblxuICAvLyBCdWlsZCBVUkwgd2l0aCBjcmVkZW50aWFscyBhbmQgcGFyYW1zXG4gIGxldCB1cmw6IFVSTFxuICB0cnkge1xuICAgIHVybCA9IG5ldyBVUkwoYXBpVXJsKVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHRocm93IG5ldyBFcnJvcihgVVJMIGludsOhbGlkYTogJHthcGlVcmx9LiBWZXJpZmlxdWUgYSBjb25maWd1cmHDp8Ojby5gKVxuICB9XG5cbiAgLy8gQ2hlY2sgZm9yIHBvdGVudGlhbCBtaXhlZCBjb250ZW50IGlzc3Vlc1xuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cubG9jYXRpb24ucHJvdG9jb2wgPT09IFwiaHR0cHM6XCIgJiYgdXJsLnByb3RvY29sID09PSBcImh0dHA6XCIpIHtcbiAgICBjb25zb2xlLndhcm4oXCJQb3RlbnRpYWwgbWl4ZWQgY29udGVudCBpc3N1ZTogdHJ5aW5nIHRvIGxvYWQgSFRUUCBjb250ZW50IGluIGFuIEhUVFBTIHBhZ2VcIilcbiAgfVxuXG4gIC8vIEFkZCBhdXRoZW50aWNhdGlvbiBwYXJhbXMgYW5kIGFjdGlvblxuICBjb25zdCBxdWVyeVBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoe1xuICAgIHVzZXJuYW1lLFxuICAgIHBhc3N3b3JkLFxuICAgIGFjdGlvbjogZW5kcG9pbnQsIC8vIEFkZCB0aGUgYWN0aW9uIHBhcmFtZXRlciBoZXJlXG4gICAgLi4ucGFyYW1zLFxuICB9KVxuXG4gIGxldCBmdWxsVXJsID0gYCR7dXJsLnRvU3RyaW5nKCl9PyR7cXVlcnlQYXJhbXMudG9TdHJpbmcoKX1gXG5cbiAgdHJ5IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGZ1bGxVcmwsIHtcbiAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgIG1vZGU6IFwiY29yc1wiLCAvLyBBbHRlcmFkbyBkZSBcIm5vLWNvcnNcIiBwYXJhIFwiY29yc1wiXG4gICAgICBjcmVkZW50aWFsczogXCJvbWl0XCIsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgIFwiYWNjZXB0XCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICBcImFjY2VwdC1sYW5ndWFnZVwiOiBcInB0LUJSLHB0O3E9MC45LGVuLVVTO3E9MC44LGVuO3E9MC43XCIsXG4gICAgICB9LFxuICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KDMwMDAwKSwgLy8gVGltZW91dCBkZSAzMCBzZWd1bmRvc1xuICAgIH0pXG5cbiAgICAvLyBDbG9uZSB0aGUgcmVzcG9uc2UgZm9yIGRlYnVnZ2luZ1xuICAgIGNvbnN0IHJlc3BvbnNlQ2xvbmUgPSByZXNwb25zZS5jbG9uZSgpXG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlQ2xvbmUuanNvbigpXG4gICAgY29uc29sZS5sb2coXCJBUEkgUmVzcG9uc2UgRGF0YTpcIiwgZGF0YSlcblxuICAgIC8vIEhhbmRsZSBkaWZmZXJlbnQgSFRUUCBzdGF0dXMgY29kZXNcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MDEgfHwgcmVzcG9uc2Uuc3RhdHVzID09PSA0MDMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEF1dGhlbnRpY2F0aW9uRXJyb3IoKVxuICAgICAgfSBlbHNlIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQwNCkge1xuICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFcnJvcigpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgQXBpRXJyb3IoYEVycm8gbmEgQVBJOiAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCwgcmVzcG9uc2Uuc3RhdHVzKVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFBhcnNlIEpTT04gcmVzcG9uc2VcbiAgICB0cnkge1xuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKSAvLyBPIGF3YWl0IGFnb3JhIGRldmUgZnVuY2lvbmFyIGNvcnJldGFtZW50ZVxuXG4gICAgICAvLyBTb21lIEFQSXMgcmV0dXJuIGVycm9yIGluZm9ybWF0aW9uIGluIHRoZSByZXNwb25zZSBib2R5XG4gICAgICBpZiAoZGF0YSAmJiBkYXRhLmVycm9yKSB7XG4gICAgICAgIHRocm93IG5ldyBBcGlFcnJvcihgRXJybyBuYSBBUEk6ICR7ZGF0YS5lcnJvcn1gKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGF0YSBhcyBUXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBBcGlFcnJvcihcIkVycm8gYW8gcHJvY2Vzc2FyIHJlc3Bvc3RhIGRhIEFQSS4gRm9ybWF0byBpbnbDoWxpZG8uXCIpXG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIC8vIEhhbmRsZSB0aW1lb3V0IGVycm9yc1xuICAgIGlmIChlcnJvci5uYW1lID09PSBcIkFib3J0RXJyb3JcIikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkEgcmVxdWlzacOnw6NvIGRlbW9yb3UgbXVpdG8gZSBmb2kgYWJvcnRhZGEuXCIpXG4gICAgICB0aHJvdyBuZXcgTmV0d29ya0Vycm9yKFwiQSByZXF1aXNpw6fDo28gZXhjZWRldSBvIHRlbXBvIGxpbWl0ZS4gVGVudGUgbm92YW1lbnRlLlwiKVxuICAgIH1cblxuICAgIC8vIENoZWNrIHNwZWNpZmljYWxseSBmb3IgbWl4ZWQgY29udGVudCBlcnJvcnNcbiAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBUeXBlRXJyb3IpIHtcbiAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IGVycm9yLm1lc3NhZ2UudG9Mb3dlckNhc2UoKVxuXG4gICAgICBpZiAoXG4gICAgICAgIGVycm9yTWVzc2FnZS5pbmNsdWRlcyhcIm1peGVkIGNvbnRlbnRcIikgfHxcbiAgICAgICAgKGVycm9yTWVzc2FnZS5pbmNsdWRlcyhcImJsb2NrZWRcIikgJiYgZXJyb3JNZXNzYWdlLmluY2x1ZGVzKFwiaW5zZWN1cmVcIikpXG4gICAgICApIHtcbiAgICAgICAgdGhyb3cgbmV3IE5ldHdvcmtFcnJvcihcbiAgICAgICAgICBcIkVycm8gZGUgY29udGXDumRvIG1pc3RvOiBzZXUgbmF2ZWdhZG9yIGJsb3F1ZW91IGEgcmVxdWlzacOnw6NvIEhUVFAgZW0gdW0gc2l0ZSBIVFRQUy4gXCIgK1xuICAgICAgICAgICAgXCJUZW50ZSBhdGl2YXIgJ0ZvcsOnYXIgSFRUUFMnIG5hcyBjb25maWd1cmHDp8O1ZXMgb3UgdXNlIHVtIHNlcnZpZG9yIGNvbSBIVFRQUy5cIixcbiAgICAgICAgKVxuICAgICAgfVxuXG4gICAgICAvLyBIYW5kbGUgbmV0d29yayBlcnJvcnMgYW5kIGltcGxlbWVudCByZXRyeSBsb2dpY1xuICAgICAgaWYgKGVycm9yTWVzc2FnZS5pbmNsdWRlcyhcImZldGNoXCIpKSB7XG4gICAgICAgIC8vIE5ldHdvcmsgZXJyb3JcbiAgICAgICAgaWYgKHJldHJpZXMgPiAwKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coYFJldHJ5IGF0dGVtcHQgKCR7cmV0cmllc30gcmVtYWluaW5nKSBmb3IgJHtmdWxsVXJsfWApXG4gICAgICAgICAgLy8gRXhwb25lbnRpYWwgYmFja29mZjogd2FpdCBsb25nZXIgYmV0d2VlbiByZXRyaWVzXG4gICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgKDMgLSByZXRyaWVzKSAqIDEwMDApKVxuICAgICAgICAgIHJldHVybiBhcGlSZXF1ZXN0PFQ+KGVuZHBvaW50LCBwYXJhbXMsIHJldHJpZXMgLSAxKVxuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBOZXR3b3JrRXJyb3IoKVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJlLXRocm93IG90aGVyIGVycm9yc1xuICAgIHRocm93IGVycm9yXG4gIH1cbn1cblxuLy8gVXBkYXRlIHRoZSBnZXRTdHJlYW1VcmwgZnVuY3Rpb24gdG8gaGFuZGxlIEhUVFBTXG5leHBvcnQgY29uc3QgZ2V0U3RyZWFtVXJsID0gKHN0cmVhbUlkOiBzdHJpbmcsIHN0cmVhbVR5cGU6IFwibGl2ZVwiIHwgXCJtb3ZpZVwiIHwgXCJzZXJpZXNcIiwgZXBpc29kZUlkPzogc3RyaW5nKTogc3RyaW5nID0+IHtcbiAgY29uc3QgY3JlZGVudGlhbHMgPSBnZXRDcmVkZW50aWFscygpXG4gIGlmICghY3JlZGVudGlhbHMpIHtcbiAgICB0aHJvdyBuZXcgQXV0aGVudGljYXRpb25FcnJvcihcIkNyZWRlbmNpYWlzIG7Do28gZW5jb250cmFkYXMuIENvbmZpZ3VyZSBvIGFwbGljYXRpdm8gcHJpbWVpcm8uXCIpXG4gIH1cblxuICBjb25zdCB7IGFwaVVybCwgdXNlcm5hbWUsIHBhc3N3b3JkLCBmb3JjZUh0dHBzIH0gPSBjcmVkZW50aWFsc1xuICBsZXQgYmFzZVVybCA9IGFwaVVybC5yZXBsYWNlKFwicGxheWVyX2FwaS5waHBcIiwgXCJcIilcblxuICAvLyBJZiBmb3JjZUh0dHBzIGlzIGVuYWJsZWQsIGVuc3VyZSB0aGUgVVJMIHVzZXMgSFRUUFNcbiAgaWYgKGZvcmNlSHR0cHMgJiYgYmFzZVVybC50b0xvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgoXCJodHRwOlwiKSkge1xuICAgIGJhc2VVcmwgPSBiYXNlVXJsLnJlcGxhY2UoL15odHRwOi9pLCBcImh0dHBzOlwiKVxuICB9XG5cbiAgaWYgKHN0cmVhbVR5cGUgPT09IFwibGl2ZVwiKSB7XG4gICAgcmV0dXJuIGAke2Jhc2VVcmx9bGl2ZS8ke3VzZXJuYW1lfS8ke3Bhc3N3b3JkfS8ke3N0cmVhbUlkfS50c2BcbiAgfSBlbHNlIGlmIChzdHJlYW1UeXBlID09PSBcIm1vdmllXCIpIHtcbiAgICByZXR1cm4gYCR7YmFzZVVybH1tb3ZpZS8ke3VzZXJuYW1lfS8ke3Bhc3N3b3JkfS8ke3N0cmVhbUlkfS5tcDRgXG4gIH0gZWxzZSBpZiAoc3RyZWFtVHlwZSA9PT0gXCJzZXJpZXNcIikge1xuICAgIGlmICghZXBpc29kZUlkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJRCBkbyBlcGlzw7NkaW8gw6kgb2JyaWdhdMOzcmlvIHBhcmEgc8Opcmllc1wiKVxuICAgIH1cbiAgICByZXR1cm4gYCR7YmFzZVVybH1zZXJpZXMvJHt1c2VybmFtZX0vJHtwYXNzd29yZH0vJHtzdHJlYW1JZH0vJHtlcGlzb2RlSWR9Lm1wNGBcbiAgfVxuXG4gIHRocm93IG5ldyBFcnJvcihcIlRpcG8gZGUgc3RyZWFtIGludsOhbGlkb1wiKVxufVxuXG4vLyBBUEkgRW5kcG9pbnRzIGFuZCBEYXRhIE1hcHBpbmdcbmNvbnN0IEFQSV9FTkRQT0lOVFMgPSB7XG4gIEdFVF9BTExfU0VSSUVTOiBcImdldF9zZXJpZXNcIixcbiAgR0VUX0FMTF9NT1ZJRVM6IFwiZ2V0X3ZvZFwiLFxuICBHRVRfQUxMX0xJVkVfU1RSRUFNUzogXCJnZXRfbGl2ZV9zdHJlYW1zXCIsXG4gIEdFVF9TRVJJRVNfSU5GTzogXCJnZXRfc2VyaWVzX2luZm9cIixcbiAgR0VUX01PVklFX0lORk86IFwiZ2V0X3ZvZF9pbmZvXCIsXG4gIFNFQVJDSDogXCJzZWFyY2hcIixcbn1cblxuaW50ZXJmYWNlIEFwaVJlc3BvbnNlPFQ+IHtcbiAgc3RhdHVzOiBib29sZWFuXG4gIGRhdGE6IFRcbiAgZXJyb3I/OiBzdHJpbmdcbn1cblxuLy8gRGF0YSBUeXBlc1xuZXhwb3J0IGludGVyZmFjZSBDb250ZW50SXRlbSB7XG4gIGlkOiBzdHJpbmdcbiAgdGl0bGU6IHN0cmluZ1xuICBkZXNjcmlwdGlvbjogc3RyaW5nXG4gIHRodW1ibmFpbDogc3RyaW5nXG4gIGJhY2tkcm9wPzogc3RyaW5nXG4gIHR5cGU6IFwic2VyaWVzXCIgfCBcIm1vdmllXCIgfCBcImNoYW5uZWxcIlxuICBnZW5yZT86IHN0cmluZ1xuICB5ZWFyPzogc3RyaW5nXG4gIGR1cmF0aW9uPzogc3RyaW5nXG4gIHByb2dyZXNzPzogbnVtYmVyXG4gIGVwaXNvZGVzPzogRXBpc29kZVtdXG4gIGluZm8/OiBhbnlcbn1cblxuZXhwb3J0IGludGVyZmFjZSBFcGlzb2RlIHtcbiAgaWQ6IHN0cmluZ1xuICB0aXRsZTogc3RyaW5nXG4gIGRlc2NyaXB0aW9uOiBzdHJpbmdcbiAgdGh1bWJuYWlsPzogc3RyaW5nXG4gIGR1cmF0aW9uPzogc3RyaW5nXG4gIHByb2dyZXNzPzogbnVtYmVyXG4gIHNlYXNvbjogbnVtYmVyXG4gIGVwaXNvZGVOdW1iZXI6IHN0cmluZ1xufVxuXG5pbnRlcmZhY2UgU2VyaWVzUmVzcG9uc2Uge1xuICBzZXJpZXM6IHtcbiAgICBbc2VyaWVzSWQ6IHN0cmluZ106IHtcbiAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgY292ZXI6IHN0cmluZ1xuICAgICAgcGxvdDogc3RyaW5nXG4gICAgICBnZW5yZTogc3RyaW5nXG4gICAgICB5ZWFyOiBzdHJpbmdcbiAgICAgIGVwaXNvZGVfZGV0YWlsczoge1xuICAgICAgICBbZXBpc29kZUlkOiBzdHJpbmddOiB7XG4gICAgICAgICAgdGl0bGU6IHN0cmluZ1xuICAgICAgICAgIHBsb3Q6IHN0cmluZ1xuICAgICAgICAgIGVwaXNvZGVfbnVtOiBzdHJpbmdcbiAgICAgICAgICBzZWFzb25fbnVtOiBzdHJpbmdcbiAgICAgICAgICBkdXJhdGlvbjogc3RyaW5nXG4gICAgICAgICAgY3VzdG9tX3NpZDogc3RyaW5nXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuaW50ZXJmYWNlIE1vdmllUmVzcG9uc2Uge1xuICB2b2Q6IHtcbiAgICBbbW92aWVJZDogc3RyaW5nXToge1xuICAgICAgbmFtZTogc3RyaW5nXG4gICAgICBjb3Zlcjogc3RyaW5nXG4gICAgICBwbG90OiBzdHJpbmdcbiAgICAgIGdlbnJlOiBzdHJpbmdcbiAgICAgIHllYXI6IHN0cmluZ1xuICAgICAgZHVyYXRpb246IHN0cmluZ1xuICAgIH1cbiAgfVxufVxuXG5pbnRlcmZhY2UgTGl2ZVN0cmVhbVJlc3BvbnNlIHtcbiAgbGl2ZToge1xuICAgIFtjaGFubmVsSWQ6IHN0cmluZ106IHtcbiAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgc3RyZWFtX2ljb246IHN0cmluZ1xuICAgICAgZXBnX2NoYW5uZWxfaWQ6IHN0cmluZ1xuICAgIH1cbiAgfVxufVxuXG4vLyBBUEkgQ2FsbHNcbmV4cG9ydCBjb25zdCBnZXRBbGxTZXJpZXMgPSBhc3luYyAocGFnZSA9IDEsIHBhZ2VTaXplID0gMzApOiBQcm9taXNlPENvbnRlbnRJdGVtW10+ID0+IHtcbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGlSZXF1ZXN0PGFueT4oXCJnZXRfc2VyaWVzXCIpXG4gIGxldCBpdGVtczogYW55W10gPSBbXVxuICBpZiAoQXJyYXkuaXNBcnJheShyZXNwb25zZSkpIHtcbiAgICBpdGVtcyA9IHJlc3BvbnNlXG4gIH0gZWxzZSBpZiAocmVzcG9uc2UgJiYgdHlwZW9mIHJlc3BvbnNlID09PSBcIm9iamVjdFwiKSB7XG4gICAgaXRlbXMgPSBPYmplY3QudmFsdWVzKHJlc3BvbnNlKVxuICB9XG4gIGNvbnN0IHN0YXJ0ID0gKHBhZ2UgLSAxKSAqIHBhZ2VTaXplXG4gIGNvbnN0IGVuZCA9IHN0YXJ0ICsgcGFnZVNpemVcbiAgcmV0dXJuIGl0ZW1zLnNsaWNlKHN0YXJ0LCBlbmQpLm1hcChtYXBTZXJpZXNUb0NvbnRlbnQpXG59XG5cbmV4cG9ydCBjb25zdCBnZXRBbGxNb3ZpZXMgPSBhc3luYyAoKTogUHJvbWlzZTxDb250ZW50SXRlbVtdPiA9PiB7XG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpUmVxdWVzdDxhbnk+KFwiZ2V0X3ZvZFwiKVxuICBsZXQgaXRlbXM6IGFueVtdID0gW11cbiAgaWYgKEFycmF5LmlzQXJyYXkocmVzcG9uc2UpKSB7XG4gICAgaXRlbXMgPSByZXNwb25zZVxuICB9IGVsc2UgaWYgKHJlc3BvbnNlICYmIHR5cGVvZiByZXNwb25zZSA9PT0gXCJvYmplY3RcIiAmJiByZXNwb25zZS52b2QpIHtcbiAgICBpdGVtcyA9IE9iamVjdC52YWx1ZXMocmVzcG9uc2Uudm9kKVxuICB9XG4gIHJldHVybiBpdGVtcy5tYXAobWFwTW92aWVUb0NvbnRlbnQpXG59XG5cbmV4cG9ydCBjb25zdCBnZXRBbGxMaXZlU3RyZWFtcyA9IGFzeW5jICgpOiBQcm9taXNlPENvbnRlbnRJdGVtW10+ID0+IHtcbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGlSZXF1ZXN0PGFueT4oXCJnZXRfbGl2ZV9zdHJlYW1zXCIpXG4gIGxldCBpdGVtczogYW55W10gPSBbXVxuICBpZiAoQXJyYXkuaXNBcnJheShyZXNwb25zZSkpIHtcbiAgICBpdGVtcyA9IHJlc3BvbnNlXG4gIH0gZWxzZSBpZiAocmVzcG9uc2UgJiYgdHlwZW9mIHJlc3BvbnNlID09PSBcIm9iamVjdFwiICYmIHJlc3BvbnNlLmxpdmUpIHtcbiAgICBpdGVtcyA9IE9iamVjdC52YWx1ZXMocmVzcG9uc2UubGl2ZSlcbiAgfVxuICByZXR1cm4gaXRlbXMubWFwKG1hcENoYW5uZWxUb0NvbnRlbnQpXG59XG5cbmV4cG9ydCBjb25zdCBnZXRTZXJpZXNJbmZvID0gYXN5bmMgKHNlcmllc0lkOiBzdHJpbmcpOiBQcm9taXNlPGFueT4gPT4ge1xuICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaVJlcXVlc3Q8YW55PihBUElfRU5EUE9JTlRTLkdFVF9TRVJJRVNfSU5GTywgeyBzZXJpZXNfaWQ6IHNlcmllc0lkIH0pXG4gIHJldHVybiByZXNwb25zZVxufVxuXG5leHBvcnQgY29uc3QgZ2V0TW92aWVJbmZvID0gYXN5bmMgKHZvZElkOiBzdHJpbmcpOiBQcm9taXNlPGFueT4gPT4ge1xuICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaVJlcXVlc3Q8YW55PihBUElfRU5EUE9JTlRTLkdFVF9NT1ZJRV9JTkZPLCB7IHZvZF9pZDogdm9kSWQgfSlcbiAgcmV0dXJuIHJlc3BvbnNlXG59XG5cbmV4cG9ydCBjb25zdCBzZWFyY2hDb250ZW50ID0gYXN5bmMgKHF1ZXJ5OiBzdHJpbmcpOiBQcm9taXNlPENvbnRlbnRJdGVtW10+ID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaVJlcXVlc3Q8YW55PihBUElfRU5EUE9JTlRTLlNFQVJDSCwgeyBxdWVyeTogcXVlcnkgfSlcblxuICAgIGlmICghcmVzcG9uc2UgfHwgIXJlc3BvbnNlLmRhdGEpIHtcbiAgICAgIHJldHVybiBbXVxuICAgIH1cblxuICAgIGNvbnN0IHNlcmllc1Jlc3VsdHMgPSBBcnJheS5pc0FycmF5KHJlc3BvbnNlLmRhdGEuc2VyaWVzKVxuICAgICAgPyByZXNwb25zZS5kYXRhLnNlcmllcy5tYXAobWFwU2VyaWVzVG9Db250ZW50KVxuICAgICAgOiBPYmplY3QudmFsdWVzKHJlc3BvbnNlLmRhdGEuc2VyaWVzIHx8IHt9KS5tYXAobWFwU2VyaWVzVG9Db250ZW50KVxuICAgIGNvbnN0IG1vdmllUmVzdWx0cyA9IEFycmF5LmlzQXJyYXkocmVzcG9uc2UuZGF0YS52b2QpXG4gICAgICA/IHJlc3BvbnNlLmRhdGEudm9kLm1hcChtYXBNb3ZpZVRvQ29udGVudClcbiAgICAgIDogT2JqZWN0LnZhbHVlcyhyZXNwb25zZS5kYXRhLnZvZCB8fCB7fSkubWFwKG1hcE1vdmllVG9Db250ZW50KVxuICAgIGNvbnN0IGNoYW5uZWxSZXN1bHRzID0gQXJyYXkuaXNBcnJheShyZXNwb25zZS5kYXRhLmxpdmUpXG4gICAgICA/IHJlc3BvbnNlLmRhdGEubGl2ZS5tYXAobWFwQ2hhbm5lbFRvQ29udGVudClcbiAgICAgIDogT2JqZWN0LnZhbHVlcyhyZXNwb25zZS5kYXRhLmxpdmUgfHwge30pLm1hcChtYXBDaGFubmVsVG9Db250ZW50KVxuXG4gICAgcmV0dXJuIFsuLi5zZXJpZXNSZXN1bHRzLCAuLi5tb3ZpZVJlc3VsdHMsIC4uLmNoYW5uZWxSZXN1bHRzXVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJTZWFyY2ggZmFpbGVkOlwiLCBlcnJvcilcbiAgICByZXR1cm4gW11cbiAgfVxufVxuXG4vLyBEYXRhIE1hcHBpbmcgRnVuY3Rpb25zXG5leHBvcnQgY29uc3QgbWFwU2VyaWVzVG9Db250ZW50ID0gKHNlcmllczogYW55KTogQ29udGVudEl0ZW0gPT4gKHtcbiAgaWQ6IFN0cmluZyhzZXJpZXMuc2VyaWVzX2lkID8/IHNlcmllcy5pZCksXG4gIHRpdGxlOiBzZXJpZXMubmFtZSA/PyBzZXJpZXMudGl0bGUsXG4gIGRlc2NyaXB0aW9uOiBzZXJpZXMucGxvdCA/PyBcIlwiLFxuICB0aHVtYm5haWw6IHNlcmllcy5jb3ZlciA/PyBcIlwiLFxuICB0eXBlOiBcInNlcmllc1wiLFxuICBnZW5yZTogc2VyaWVzLmdlbnJlID8/IFwiXCIsXG4gIHllYXI6IHNlcmllcy55ZWFyID8/IFwiXCIsXG4gIGJhY2tkcm9wOiBBcnJheS5pc0FycmF5KHNlcmllcy5iYWNrZHJvcF9wYXRoKSA/IHNlcmllcy5iYWNrZHJvcF9wYXRoWzBdIDogdW5kZWZpbmVkLFxuICBpbmZvOiBzZXJpZXMsXG59KVxuXG5leHBvcnQgY29uc3QgbWFwTW92aWVUb0NvbnRlbnQgPSAobW92aWU6IGFueSk6IENvbnRlbnRJdGVtID0+ICh7XG4gIGlkOiBtb3ZpZS5pZCxcbiAgdGl0bGU6IG1vdmllLm5hbWUsXG4gIGRlc2NyaXB0aW9uOiBtb3ZpZS5wbG90LFxuICB0aHVtYm5haWw6IG1vdmllLmNvdmVyLFxuICB0eXBlOiBcIm1vdmllXCIsXG4gIGdlbnJlOiBtb3ZpZS5nZW5yZSxcbiAgeWVhcjogbW92aWUueWVhcixcbiAgZHVyYXRpb246IG1vdmllLmR1cmF0aW9uLFxufSlcblxuZXhwb3J0IGNvbnN0IG1hcENoYW5uZWxUb0NvbnRlbnQgPSAoY2hhbm5lbDogYW55KTogQ29udGVudEl0ZW0gPT4gKHtcbiAgaWQ6IGNoYW5uZWwuaWQsXG4gIHRpdGxlOiBjaGFubmVsLm5hbWUsXG4gIGRlc2NyaXB0aW9uOiBcIlwiLFxuICB0aHVtYm5haWw6IGNoYW5uZWwuc3RyZWFtX2ljb24sXG4gIHR5cGU6IFwiY2hhbm5lbFwiLFxufSlcblxuZXhwb3J0IGNvbnN0IG1hcFNlcmllc0RldGFpbHNUb0NvbnRlbnQgPSAoc2VyaWVzRGV0YWlsczogYW55KTogQ29udGVudEl0ZW0gPT4ge1xuICBjb25zdCBzZXJpZXMgPSBzZXJpZXNEZXRhaWxzLmluZm9cbiAgY29uc3QgZXBpc29kZXM6IEVwaXNvZGVbXSA9IFtdXG5cbiAgLy8gUHJvY2Vzc2FyIGVwaXPDs2Rpb3MgZGUgdG9kYXMgYXMgdGVtcG9yYWRhc1xuICBPYmplY3QuZW50cmllcyhzZXJpZXNEZXRhaWxzLmVwaXNvZGVzIHx8IHt9KS5mb3JFYWNoKChbc2Vhc29uTnVtLCBzZWFzb25FcGlzb2Rlc106IFtzdHJpbmcsIGFueV0pID0+IHtcbiAgICBzZWFzb25FcGlzb2Rlcy5mb3JFYWNoKChlcGlzb2RlOiBhbnkpID0+IHtcbiAgICAgIGVwaXNvZGVzLnB1c2goe1xuICAgICAgICBpZDogZXBpc29kZS5pZCxcbiAgICAgICAgdGl0bGU6IGVwaXNvZGUudGl0bGUsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBlcGlzb2RlLmluZm8/LnBsb3QgfHwgXCJcIixcbiAgICAgICAgdGh1bWJuYWlsOiBlcGlzb2RlLmluZm8/Lm1vdmllX2ltYWdlIHx8IGVwaXNvZGUuaW5mbz8uY292ZXJfYmlnIHx8IHNlcmllcy5jb3ZlcixcbiAgICAgICAgZHVyYXRpb246IGVwaXNvZGUuaW5mbz8uZHVyYXRpb24gfHwgXCJcIixcbiAgICAgICAgc2Vhc29uOiBlcGlzb2RlLnNlYXNvbixcbiAgICAgICAgZXBpc29kZU51bWJlcjogZXBpc29kZS5lcGlzb2RlX251bSxcbiAgICAgIH0pXG4gICAgfSlcbiAgfSlcblxuICAvLyBPcmRlbmFyIGVwaXPDs2Rpb3MgcG9yIHRlbXBvcmFkYSBlIG7Dum1lcm8gZG8gZXBpc8OzZGlvXG4gIGVwaXNvZGVzLnNvcnQoKGEsIGIpID0+IHtcbiAgICBpZiAoYS5zZWFzb24gIT09IGIuc2Vhc29uKSB7XG4gICAgICByZXR1cm4gYS5zZWFzb24gLSBiLnNlYXNvblxuICAgIH1cbiAgICByZXR1cm4gcGFyc2VJbnQoYS5lcGlzb2RlTnVtYmVyKSAtIHBhcnNlSW50KGIuZXBpc29kZU51bWJlcilcbiAgfSlcblxuICByZXR1cm4ge1xuICAgIGlkOiBzZXJpZXMuaWQsXG4gICAgdGl0bGU6IHNlcmllcy5uYW1lIHx8IHNlcmllcy50aXRsZSxcbiAgICBkZXNjcmlwdGlvbjogc2VyaWVzLnBsb3QsXG4gICAgdGh1bWJuYWlsOiBzZXJpZXMuY292ZXIsXG4gICAgdHlwZTogXCJzZXJpZXNcIixcbiAgICBnZW5yZTogc2VyaWVzLmdlbnJlLFxuICAgIHllYXI6IHNlcmllcy55ZWFyLFxuICAgIGJhY2tkcm9wOiBBcnJheS5pc0FycmF5KHNlcmllcy5iYWNrZHJvcF9wYXRoKSA/IHNlcmllcy5iYWNrZHJvcF9wYXRoWzBdIDogdW5kZWZpbmVkLFxuICAgIGVwaXNvZGVzOiBlcGlzb2RlcyxcbiAgICBpbmZvOiB7XG4gICAgICAuLi5zZXJpZXMsXG4gICAgICBzZWFzb25zOiBzZXJpZXNEZXRhaWxzLnNlYXNvbnMsXG4gICAgfSxcbiAgfVxufVxuXG4vLyBMb2NhbCBTdG9yYWdlIEZ1bmN0aW9uc1xuY29uc3QgUFJPR1JFU1NfS0VZID0gXCJjb250ZW50UHJvZ3Jlc3NcIlxuXG5leHBvcnQgY29uc3Qgc2F2ZUNvbnRlbnRQcm9ncmVzcyA9IChjb250ZW50SWQ6IHN0cmluZywgY3VycmVudFRpbWU6IG51bWJlciwgZHVyYXRpb246IG51bWJlciwgZXBpc29kZUlkPzogc3RyaW5nKSA9PiB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSByZXR1cm5cblxuICB0cnkge1xuICAgIGNvbnN0IHByb2dyZXNzRGF0YSA9IEpTT04ucGFyc2UobG9jYWxTdG9yYWdlLmdldEl0ZW0oUFJPR1JFU1NfS0VZKSB8fCBcInt9XCIpXG4gICAgcHJvZ3Jlc3NEYXRhW2NvbnRlbnRJZCArIChlcGlzb2RlSWQgPyBgXyR7ZXBpc29kZUlkfWAgOiBcIlwiKV0gPSB7IGN1cnJlbnRUaW1lLCBkdXJhdGlvbiB9XG4gICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oUFJPR1JFU1NfS0VZLCBKU09OLnN0cmluZ2lmeShwcm9ncmVzc0RhdGEpKVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gc2F2ZSBjb250ZW50IHByb2dyZXNzOlwiLCBlcnJvcilcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgZ2V0Q29udGVudEN1cnJlbnRUaW1lID0gKGNvbnRlbnRJZDogc3RyaW5nLCBlcGlzb2RlSWQ/OiBzdHJpbmcpOiBudW1iZXIgfCBudWxsID0+IHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHJldHVybiBudWxsXG5cbiAgdHJ5IHtcbiAgICBjb25zdCBwcm9ncmVzc0RhdGEgPSBKU09OLnBhcnNlKGxvY2FsU3RvcmFnZS5nZXRJdGVtKFBST0dSRVNTX0tFWSkgfHwgXCJ7fVwiKVxuICAgIGNvbnN0IHByb2dyZXNzID0gcHJvZ3Jlc3NEYXRhW2NvbnRlbnRJZCArIChlcGlzb2RlSWQgPyBgXyR7ZXBpc29kZUlkfWAgOiBcIlwiKV1cbiAgICByZXR1cm4gcHJvZ3Jlc3MgPyBwcm9ncmVzcy5jdXJyZW50VGltZSA6IG51bGxcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIGdldCBjb250ZW50IHByb2dyZXNzOlwiLCBlcnJvcilcbiAgICByZXR1cm4gbnVsbFxuICB9XG59XG5cbi8vIFRlc3QgQ29ubmVjdGlvblxuZXhwb3J0IGNvbnN0IHRlc3RDb25uZWN0aW9uID0gYXN5bmMgKCk6IFByb21pc2U8Ym9vbGVhbj4gPT4ge1xuICB0cnkge1xuICAgIC8vIEF0dGVtcHQgdG8gZmV0Y2ggc2VyaWVzIChhIGJhc2ljIEFQSSBjYWxsKVxuICAgIGF3YWl0IGdldEFsbFNlcmllcygxLCAxKVxuICAgIHJldHVybiB0cnVlXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihcIkNvbm5lY3Rpb24gdGVzdCBmYWlsZWQ6XCIsIGVycm9yKVxuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbi8vIEVycm9yIE1lc3NhZ2UgSGVscGVyXG5leHBvcnQgY29uc3QgZ2V0RXJyb3JNZXNzYWdlID0gKGVycm9yOiBhbnkpOiBzdHJpbmcgPT4ge1xuICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBBdXRoZW50aWNhdGlvbkVycm9yKSB7XG4gICAgcmV0dXJuIFwiRmFsaGEgbmEgYXV0ZW50aWNhw6fDo28uIFZlcmlmaXF1ZSBzdWFzIGNyZWRlbmNpYWlzLlwiXG4gIH0gZWxzZSBpZiAoZXJyb3IgaW5zdGFuY2VvZiBOb3RGb3VuZEVycm9yKSB7XG4gICAgcmV0dXJuIFwiUmVjdXJzbyBuw6NvIGVuY29udHJhZG8uXCJcbiAgfSBlbHNlIGlmIChlcnJvciBpbnN0YW5jZW9mIEFwaUVycm9yKSB7XG4gICAgcmV0dXJuIGBFcnJvIG5hIEFQSTogJHtlcnJvci5tZXNzYWdlfWBcbiAgfSBlbHNlIGlmIChlcnJvciBpbnN0YW5jZW9mIE5ldHdvcmtFcnJvcikge1xuICAgIHJldHVybiBcIkVycm8gZGUgcmVkZS4gVmVyaWZpcXVlIHN1YSBjb25leMOjbyBjb20gYSBpbnRlcm5ldC5cIlxuICB9IGVsc2UgaWYgKGVycm9yIGluc3RhbmNlb2YgVHlwZUVycm9yICYmIGVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoXCJGYWlsZWQgdG8gZmV0Y2hcIikpIHtcbiAgICByZXR1cm4gXCJFcnJvIGFvIGNvbmVjdGFyIGFvIHNlcnZpZG9yLiBWZXJpZmlxdWUgYSBVUkwgZSBzdWEgY29uZXjDo28uXCJcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gXCJPY29ycmV1IHVtIGVycm8gaW5lc3BlcmFkby5cIlxuICB9XG59XG4iXSwibmFtZXMiOlsiQXV0aGVudGljYXRpb25FcnJvciIsIkVycm9yIiwiY29uc3RydWN0b3IiLCJtZXNzYWdlIiwibmFtZSIsIk5vdEZvdW5kRXJyb3IiLCJBcGlFcnJvciIsInN0YXR1c0NvZGUiLCJOZXR3b3JrRXJyb3IiLCJnZXRDcmVkZW50aWFscyIsInN0b3JlZENvbmZpZyIsImxvY2FsU3RvcmFnZSIsImdldEl0ZW0iLCJjcmVkZW50aWFscyIsIkpTT04iLCJwYXJzZSIsImZvcmNlSHR0cHMiLCJhcGlVcmwiLCJ0b0xvd2VyQ2FzZSIsInN0YXJ0c1dpdGgiLCJyZXBsYWNlIiwiZXJyb3IiLCJjb25zb2xlIiwiYXBpUmVxdWVzdCIsImVuZHBvaW50IiwicGFyYW1zIiwicmV0cmllcyIsInVzZXJuYW1lIiwicGFzc3dvcmQiLCJ1cmwiLCJVUkwiLCJ3aW5kb3ciLCJsb2NhdGlvbiIsInByb3RvY29sIiwid2FybiIsInF1ZXJ5UGFyYW1zIiwiVVJMU2VhcmNoUGFyYW1zIiwiYWN0aW9uIiwiZnVsbFVybCIsInRvU3RyaW5nIiwicmVzcG9uc2UiLCJmZXRjaCIsIm1ldGhvZCIsIm1vZGUiLCJoZWFkZXJzIiwic2lnbmFsIiwiQWJvcnRTaWduYWwiLCJ0aW1lb3V0IiwicmVzcG9uc2VDbG9uZSIsImNsb25lIiwiZGF0YSIsImpzb24iLCJsb2ciLCJvayIsInN0YXR1cyIsInN0YXR1c1RleHQiLCJUeXBlRXJyb3IiLCJlcnJvck1lc3NhZ2UiLCJpbmNsdWRlcyIsIlByb21pc2UiLCJyZXNvbHZlIiwic2V0VGltZW91dCIsImdldFN0cmVhbVVybCIsInN0cmVhbUlkIiwic3RyZWFtVHlwZSIsImVwaXNvZGVJZCIsImJhc2VVcmwiLCJBUElfRU5EUE9JTlRTIiwiR0VUX0FMTF9TRVJJRVMiLCJHRVRfQUxMX01PVklFUyIsIkdFVF9BTExfTElWRV9TVFJFQU1TIiwiR0VUX1NFUklFU19JTkZPIiwiR0VUX01PVklFX0lORk8iLCJTRUFSQ0giLCJnZXRBbGxTZXJpZXMiLCJwYWdlIiwicGFnZVNpemUiLCJpdGVtcyIsIkFycmF5IiwiaXNBcnJheSIsIk9iamVjdCIsInZhbHVlcyIsInN0YXJ0IiwiZW5kIiwic2xpY2UiLCJtYXAiLCJtYXBTZXJpZXNUb0NvbnRlbnQiLCJnZXRBbGxNb3ZpZXMiLCJ2b2QiLCJtYXBNb3ZpZVRvQ29udGVudCIsImdldEFsbExpdmVTdHJlYW1zIiwibGl2ZSIsIm1hcENoYW5uZWxUb0NvbnRlbnQiLCJnZXRTZXJpZXNJbmZvIiwic2VyaWVzSWQiLCJzZXJpZXNfaWQiLCJnZXRNb3ZpZUluZm8iLCJ2b2RJZCIsInZvZF9pZCIsInNlYXJjaENvbnRlbnQiLCJxdWVyeSIsInNlcmllc1Jlc3VsdHMiLCJzZXJpZXMiLCJtb3ZpZVJlc3VsdHMiLCJjaGFubmVsUmVzdWx0cyIsImlkIiwiU3RyaW5nIiwidGl0bGUiLCJkZXNjcmlwdGlvbiIsInBsb3QiLCJ0aHVtYm5haWwiLCJjb3ZlciIsInR5cGUiLCJnZW5yZSIsInllYXIiLCJiYWNrZHJvcCIsImJhY2tkcm9wX3BhdGgiLCJ1bmRlZmluZWQiLCJpbmZvIiwibW92aWUiLCJkdXJhdGlvbiIsImNoYW5uZWwiLCJzdHJlYW1faWNvbiIsIm1hcFNlcmllc0RldGFpbHNUb0NvbnRlbnQiLCJzZXJpZXNEZXRhaWxzIiwiZXBpc29kZXMiLCJlbnRyaWVzIiwiZm9yRWFjaCIsInNlYXNvbk51bSIsInNlYXNvbkVwaXNvZGVzIiwiZXBpc29kZSIsInB1c2giLCJtb3ZpZV9pbWFnZSIsImNvdmVyX2JpZyIsInNlYXNvbiIsImVwaXNvZGVOdW1iZXIiLCJlcGlzb2RlX251bSIsInNvcnQiLCJhIiwiYiIsInBhcnNlSW50Iiwic2Vhc29ucyIsIlBST0dSRVNTX0tFWSIsInNhdmVDb250ZW50UHJvZ3Jlc3MiLCJjb250ZW50SWQiLCJjdXJyZW50VGltZSIsInByb2dyZXNzRGF0YSIsInNldEl0ZW0iLCJzdHJpbmdpZnkiLCJnZXRDb250ZW50Q3VycmVudFRpbWUiLCJwcm9ncmVzcyIsInRlc3RDb25uZWN0aW9uIiwiZ2V0RXJyb3JNZXNzYWdlIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/api-service.ts\n"));

/***/ })

});